<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ç”»åƒã‚«ãƒ©ãƒ¼åˆ†æ</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&family=Zen+Maru+Gothic&display=swap" rel="stylesheet">
<style>
:root {
/* --- ğŸ¨ ã‚«ãƒ©ãƒ¼è¨­å®š --- */
--bg-color: #dbdbd7; 	 /* å…¨ä½“ã®èƒŒæ™¯è‰² (æ·¡ã„ã‚°ãƒ¬ãƒ¼) */
--main-card-bg: #dbdbd7; 	 /* ã‚«ãƒ¼ãƒ‰ã®èƒŒæ™¯è‰² (èƒŒæ™¯ã¨åŒã˜) */
--text-color-primary: #111111; /* ãƒ¡ã‚¤ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®è‰² (é»’) */
--text-color-subtle: #111111; 	/* ã‚µãƒ–ãƒ†ã‚­ã‚¹ãƒˆã®è‰² (ã‚°ãƒ¬ãƒ¼) */
--accent-color: #b95282; 	 /* å¼·èª¿è‰² (ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚„ãƒ›ãƒãƒ¼) */
--scope-grid-color: #a77d54; /* ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®ã‚°ãƒªãƒƒãƒ‰è‰² (ã‚´ãƒ¼ãƒ«ãƒ‰ç³») */
--scope-bg-color: #000000; /* ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®èƒŒæ™¯è‰² (é»’) */

/* --- ğŸ“ ç½«ç·šãƒ»ãƒ‡ã‚¶ã‚¤ãƒ³è¨­å®š --- */
--border-color: #111111; 	 /* ç¸å–ã‚Šã®è‰² (é»’) */
--card-radius: 8px; 	 	/* ã‚«ãƒ¼ãƒ‰ã®è§’ä¸¸ã‚µã‚¤ã‚º */
--line-subtle: #111111; 	 	/* ç´°ã„ç·šã®è‰² */
--line-strong: #111111; 	 	/* å¼·èª¿ç·šã®è‰² */
--threshold-color: #FFFFFF; 	/* é–¾å€¤ã®è‰² */

/* --- ğŸ–‹ï¸ ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š --- */
--font-heading: 'Montserrat', "Zen Maru Gothic", sans-serif;
--font-body: 'Zen Maru Gothic', 'Montserrat', sans-serif;
--font-futura: 'Montserrat', sans-serif; /* ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®è¨ˆæ¸¬å€¤ç”¨ */
}

body {
font-family: var(--font-body);
text-align: center;
background: var(--bg-color);
margin: 0;
padding: 60px 40px;
color: var(--text-color-primary);
min-height: 100vh;
box-sizing: border-box;
display: flex;
flex-direction: column;
align-items: center;
font-weight: 400; 
}

h2 {
font-size: 36px;
font-weight: 500; 
color: var(--text-color-primary);
margin-bottom: 5px;
font-family: var(--font-heading);
letter-spacing: 0.05em;
}

.sub-text {
color: var(--text-color-subtle);
font-size: 14px;
font-family: var(--font-body);
line-height: 1.7;
margin-bottom: 50px;
}

/* --- ãƒ‰ãƒ­ãƒƒãƒ—é ˜åŸŸ (åˆæœŸçŠ¶æ…‹) --- */
#initialDropArea {
position: relative;
width: 800px;
height: 450px;
background-color: var(--main-card-bg);
display: flex;
justify-content: center;
align-items: center;
margin: 0 auto;
cursor: pointer;
transition: background-color 0.3s ease, border-color 0.3s ease;

border: 1px solid var(--border-color);
border-radius: var(--card-radius);
}

#initialDropArea:hover, #initialDropArea.highlight {
background-color: #be7792; 
border-color: var(--accent-color); 
}

#initialDropArea p {
color: var(--text-color-primary);
font-size: 24px;
font-weight: 500;
font-family: var(--font-body);
background-color: transparent;
padding: 5px 15px;
border: 1px solid var(--text-color-primary);
line-height: 1;
}

#initialFileInput {
display: none;
}

/* --- è§£æçµæœã‚³ãƒ³ãƒ†ãƒŠ --- */
@keyframes fadeIn {
from { opacity: 0; transform: translateY(10px); }
to { opacity: 1; transform: translateY(0); }
}

#analysisContainer {
opacity: 0;
animation: fadeIn 0.8s ease-out forwards;
animation-delay: 0.1s;
width: 100%;
max-width: 1200px;
margin-top: 40px;
display: grid;
grid-template-columns: 1fr 1fr;
gap: 40px;
align-items: start;
}

/* å·¦å´ã®ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¨ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®ãƒ‘ãƒãƒ« */
.left-panel {
display: flex;
flex-direction: column;
background-color: var(--main-card-bg);
padding: 30px;
color: var(--text-color-primary);
text-align: left;

border: 1px solid var(--border-color);
border-radius: var(--card-radius);
}

#imagePlaceholder {
width: 100%;
aspect-ratio: 16 / 9;
background-color: #222222;
display: flex;
justify-content: center;
align-items: center;
font-size: 24px;
font-weight: 500;
color: var(--text-color-subtle);
margin-bottom: 20px;
}

/* <img> ã‹ã‚‰ <canvas> ã«å¤‰æ›´ */
#resultImagePreview {
width: 100%;
height: auto;
display: none;
margin-bottom: 20px;
border: none;
cursor: crosshair; /* ã‚¹ãƒã‚¤ãƒˆæ©Ÿèƒ½ã®ãŸã‚ã«ã‚«ãƒ¼ã‚½ãƒ«ã‚’å¤‰æ›´ */
}

/* ã‚¼ãƒ–ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« (ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼) ã®UI */
#zebraControls {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 14px;
    padding: 10px;
    border-top: 1px dashed var(--line-subtle);
    border-bottom: 1px dashed var(--line-subtle);
    gap: 10px;
    color: var(--text-color-primary);
}
#zebraControls label {
    margin-right: 5px;
    white-space: nowrap;
    color: var(--text-color-subtle);
}
#zebraControls input[type="range"] {
    flex-grow: 1;
    margin: 0 5px;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: var(--line-subtle);
    outline: none;
    opacity: 0.7;
    transition: opacity .2s;
    border-radius: 2px;
}
#zebraControls input[type="range"]:hover {
    opacity: 1;
}
#zebraControls input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--accent-color);
    cursor: pointer;
}
#zebraControls input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--accent-color);
    cursor: pointer;
}

#zebraControls input[type="number"] {
    width: 45px;
    font-family: var(--font-futura);
    text-align: center;
    border: 1px solid var(--line-subtle);
    background-color: var(--main-card-bg);
    color: var(--text-color-primary);
    padding: 3px 0;
    border-radius: 4px;
}
#zebraControls input[type="number"]:focus {
    outline: none;
    border-color: var(--accent-color);
}

#zebraControls input[type="checkbox"] {
    width: 16px;
    height: 16px;
    -webkit-appearance: none;
    appearance: none;
    border: 1px solid var(--line-subtle);
    border-radius: 3px;
    outline: none;
    cursor: pointer;
    background-color: var(--main-card-bg);
    position: relative;
    top: 2px;
}
#zebraControls input[type="checkbox"]:checked {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
}
#zebraControls input[type="checkbox"]:checked::after {
    content: 'âœ”';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #fff;
    font-size: 10px;
    font-weight: bold;
}


.hist-label {
font-size: 20px;
font-weight: 500;
margin-top: 30px;
margin-bottom: 15px;
padding-top: 15px;
text-align: center;
font-family: var(--font-heading);
}

#histogramCanvas {
width: 100%;
height: 120px;
display: block;
background-color: var(--main-card-bg);
}

/* å³å´ã®è§£æçµæœã¨ã‚³ãƒ”ãƒ¼ãƒœã‚¿ãƒ³ã®ãƒ‘ãƒãƒ« */
.right-panel {
display: flex;
flex-direction: column;
background-color: var(--bg-color); 
padding: 0;
color: var(--text-color-primary);
text-align: left;
}

.result-item {
display: flex;
align-items: center;
padding: 10px 0;
border-bottom: 1px solid var(--line-subtle);
cursor: pointer;
transition: background-color 0.2s ease;
}

.result-item:hover {
background-color: #e2c0d3;
}

.result-label {
width: 150px;
font-size: 16px;
font-weight: 400;
color: var(--text-color-subtle);
margin-right: 20px;
}

.result-value {
font-size: 20px;
font-weight: 500;
font-family: 'Montserrat', var(--font-futura), sans-serif;
flex-grow: 1;
}

.color-swatch {
width: 20px;
height: 20px;
border: 1px solid var(--text-color-subtle);
margin-left: 10px;
}

/* æ³¢å½¢ãƒ¢ãƒ‹ã‚¿ãƒ¼ã®UI */
.waveform-container {
    padding: 10px 0;
    border-bottom: 1px solid var(--line-subtle);
}
.waveform-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px dashed var(--line-subtle);
}
.waveform-header .hist-label {
    margin: 0; 
    padding: 0; 
    font-size: 16px; 
    text-align: left;
    color: var(--text-color-subtle);
}
.waveform-header div {
    font-size: 14px;
    display: flex;
    gap: 10px;
}
.waveform-header input[type="radio"] {
    display: none; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã‚’éš ã™ */
}
.waveform-header input[type="radio"] + label {
    cursor: pointer;
    padding: 4px 10px;
    border: 1px solid var(--line-subtle);
    border-radius: 4px;
    color: var(--text-color-primary);
    background-color: var(--main-card-bg);
    transition: background-color 0.2s, border-color 0.2s;
    font-family: var(--font-futura);
}
.waveform-header input[type="radio"]:hover + label {
    border-color: var(--accent-color);
}
.waveform-header input[type="radio"]:checked + label {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    color: #fff;
}

#waveformCanvas {
    width: 100%;
    height: 150px;
    background-color: var(--scope-bg-color);
}


/* --- ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—å°‚ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
#vectorscopeCard {
margin-top: 20px;
width: 100%;
background-color: var(--main-card-bg); /* å‘¨å›²ã®ã‚«ãƒ¼ãƒ‰ã¨æƒãˆã‚‹ */
padding: 20px;
display: flex;
flex-direction: column;
align-items: center;

border: 1px solid var(--border-color);
border-radius: var(--card-radius);
}

/* æ­£å††ã‚’ç¶­æŒã™ã‚‹ãŸã‚ã®ãƒ©ãƒƒãƒ‘ãƒ¼ */
#vectorscopeWrapper {
    width: 200px; /* ä¿®æ­£: å°ã•ãã—ã¦ã‚«ãƒ¼ãƒ‰æ ã«åã¾ã‚‹ã‚ˆã†ã« */
    height: 200px; /* ä¿®æ­£: æ­£å††ã‚’ç¶­æŒ */
    margin: 0 auto 10px auto;
}

#vectorscopeCanvas {
    width: 100%;
    height: 100%;
    display: block;
    background-color: var(--scope-bg-color); 
    border: none; 
    border-radius: 50%; 
    cursor: default;
}

.scope-data-display {
    text-align: center;
    width: 100%;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed var(--line-subtle);
    display: flex;
    justify-content: space-around;
    font-family: var(--font-futura);
}

.scope-data-item {
    font-size: 14px;
    line-height: 1.4;
}

.scope-data-label {
    font-weight: 400;
    color: var(--text-color-subtle);
    display: block;
    font-size: 12px;
}

.scope-data-value {
    font-weight: 600;
    color: var(--text-color-primary);
    display: block;
    font-size: 16px;
}
/* ------------------------------------- */

/* â˜… ä¿®æ­£: å‡¦ç†æ¸ˆã¿ç”»åƒã‚¨ãƒªã‚¢ (ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼) */
#processedImagesArea {
    margin-top: 40px;
    display: flex; 
    align-items: center;
    justify-content: center;
    background-color: var(--bg-color);
    width: 100%; 
    box-sizing: border-box;
    position: relative; /* çŸ¢å°ãƒœã‚¿ãƒ³ã®çµ¶å¯¾é…ç½®ã®ãŸã‚ */
    /* å·¦å³ã®ãƒœã‚¿ãƒ³ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’ç¢ºä¿ */
    padding: 0 50px;
}

/* â˜… è¿½åŠ : ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¡¨ç¤ºçª“ (ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆ) */
#processedImagesViewport {
    width: 300px; /* ã‚«ãƒ¼ãƒ‰1æšåˆ†ã®å¹… */
    overflow: hidden; /* ã¯ã¿å‡ºãŸã‚«ãƒ¼ãƒ‰ã‚’éš ã™ */
    position: relative;
}

/* â˜… è¿½åŠ : ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼æœ¬ä½“ (ã“ã®è¦ç´ ãŒå‹•ã) */
#processedImagesWrapper {
    display: flex; /* Flexboxã§ä¸­ã®ã‚«ãƒ¼ãƒ‰ã‚’æ¨ªä¸¦ã³ã« */
    transition: transform 0.4s ease-in-out; /* ã‚¹ãƒ©ã‚¤ãƒ‰ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
    width: auto; /* å¹…ã¯ã‚«ãƒ¼ãƒ‰ã®åˆè¨ˆåˆ† */
}

.processed-image-card {
    flex: 0 0 300px; /* å¹…ã‚’300pxã«å›ºå®šã—ã€ä¼¸ç¸®ã•ã›ãªã„ */
    background-color: var(--main-card-bg);
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    border: 1px solid var(--border-color);
    border-radius: var(--card-radius);
    box-sizing: border-box; /* paddingã‚’å«ã‚ã¦300px */
}

.processed-image-card canvas {
    width: 100%; 
    height: 150px; 
    display: block;
    border: none;
    margin-bottom: 10px;
    cursor: pointer;
    transition: border-color 0.2s ease;
    object-fit: contain; 
    image-rendering: pixelated; 
    background-color: #ddd; 
}

.processed-image-card canvas:hover {
    border-color: var(--line-strong);
}

.processed-image-card p {
    font-size: 14px;
    color: var(--text-color-subtle);
    margin: 0;
    white-space: normal; 
}

/* â˜… è¿½åŠ : å·¦å³ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ */
.nav-button {
    background: var(--accent-color);
    border: 1px solid var(--accent-color);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    position: absolute; /* è¦ª(#processedImagesArea)ã«å¯¾ã—ã¦çµ¶å¯¾é…ç½® */
    top: 50%;
    transform: translateY(-50%);
    z-index: 10;
    transition: background-color 0.2s, border-color 0.2s;
    color: #fff;
    opacity: 0.7;
}
.nav-button:hover {
    opacity: 1;
}
.nav-button.prev {
    left: 0px; 
}
.nav-button.next {
    right: 0px; 
}
.nav-button svg {
    stroke: #fff;
    width: 20px;
    height: 20px;
}
.nav-button:disabled {
    background-color: #999;
    border-color: #999;
    opacity: 0.3;
    cursor: not-allowed;
}


/* ãƒ•ãƒƒã‚¿ãƒ¼ */
footer {
margin-top: 80px;
font-size: 12px;
color: var(--text-color-subtle);
font-family: var(--font-body);
}

/* ã‚¹ãƒã‚¤ãƒˆæƒ…å ±ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ */
#eyedropperInfo {
    position: fixed;
    background-color: rgba(30, 30, 30, 0.85);
    color: #fff;
    padding: 8px 12px;
    border-radius: 5px;
    font-size: 12px;
    z-index: 2000;
    pointer-events: none;
    display: none;
    font-family: var(--font-futura);
    border: 1px solid #fff;
    backdrop-filter: blur(5px);
}
#eyedropperInfo .info-line {
    display: flex;
    justify-content: space-between;
}
#eyedropperInfo .info-label {
    color: #aaa;
    margin-right: 10px;
    min-width: 30px;
}
#eyedropperInfo .info-value {
    color: #fff;
    font-weight: 600;
}


/* ã‚³ãƒ”ãƒ¼ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ— */
.copy-tooltip {
position: fixed;
background-color: #333;
color: #fff;
padding: 5px 10px;
border-radius: 3px;
font-size: 12px;
z-index: 1000;
pointer-events: none;
opacity: 0;
transition: opacity 0.3s ease;
}
.copy-tooltip.show {
opacity: 1;
}

/* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
@media (max-width: 768px) {
    body {
        padding: 20px 15px; 
        min-height: auto;
    }

    h2 {
        font-size: 28px; 
    }

    .sub-text {
        font-size: 13px;
        margin-bottom: 30px;
    }

    #initialDropArea {
        width: 100%; 
        height: 250px; 
    }

    #initialDropArea p {
        font-size: 20px;
        padding: 3px 10px;
    }

    #analysisContainer {
        grid-template-columns: 1fr; 
        gap: 30px; 
    }

    .left-panel {
        padding: 20px;
    }

    .right-panel {
        padding: 0;
    }
    
    #zebraControls {
        font-size: 12px;
        padding: 8px;
        flex-wrap: wrap; 
        gap: 5px;
    }
    #zebraControls input[type="number"] {
        width: 40px;
    }

    .hist-label {
        font-size: 18px;
    }
    
    .result-item {
        padding: 8px 0;
    }

    .result-label {
        width: 120px; 
        font-size: 15px;
    }

    .result-value {
        font-size: 18px;
    }
    
    .waveform-header div {
        font-size: 12px;
    }
    #waveformCanvas {
        height: 120px;
    }

    #vectorscopeCard {
        padding: 15px;
    }

    #vectorscopeWrapper {
        width: 180px; /* ä¿®æ­£: ã‚¹ãƒãƒ›ã§ã‚‚å°ã•ã */
        height: 180px; /* ä¿®æ­£: æ­£å††ã‚’ç¶­æŒ */
    }
    
    .scope-data-display {
        font-size: 12px;
    }
    
    .scope-data-value {
        font-size: 14px;
    }

    /* â˜… ä¿®æ­£: ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */
    #processedImagesArea {
        gap: 0;
        margin-top: 30px;
        padding: 0 40px; /* ã‚¹ãƒãƒ›ã§ã‚‚ãƒœã‚¿ãƒ³ã®ã‚¹ãƒšãƒ¼ã‚¹ç¢ºä¿ */
    }
    #processedImagesViewport {
        width: 250px; /* ã‚¹ãƒãƒ›ã§ã®è¡¨ç¤ºã‚«ãƒ¼ãƒ‰å¹…ã«åˆã‚ã›ã‚‹ */
    }
    .processed-image-card {
        flex: 0 0 250px; /* ã‚¹ãƒãƒ›ã§ã®ã‚«ãƒ¼ãƒ‰å¹…ã‚’èª¿æ•´ */
        padding: 15px;
    }
    .processed-image-card canvas {
        height: 120px; /* ã‚¹ãƒãƒ›ã§ã®è¡¨ç¤ºé«˜ã•ã‚’èª¿æ•´ */
    }
    .nav-button {
        width: 30px;
        height: 30px;
    }
    .nav-button svg {
        width: 16px;
        height: 16px;
    }
    .nav-button.prev {
        left: 5px;
    }
    .nav-button.next {
        right: 5px;
    }
}
</style>
</head>
<body>

<h2>ç”»åƒã‚«ãƒ©ãƒ¼åˆ†æ</h2>
<p class="sub-text">ç”»åƒã®ç™½é»’ã®æ¯”ç‡ã¨è‰²åˆ†å¸ƒã‚’èªè­˜ã—ã¦ãã‚Œã‚‹ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚<br>ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã¨ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>

<div id="initialDropArea">
<input type="file" id="initialFileInput" accept="image/*">
<p>ç”»åƒã‚’è¿½åŠ </p>
</div>

<div id="analysisContainer" style="display: none;">

<div class="left-panel">
    
    <canvas id="resultImagePreview"></canvas>
    
    <div id="imagePlaceholder">ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚</div>

    <div id="zebraControls" style="display: none;">
        <label for="zebraToggle">ã‚¼ãƒ–ãƒ©</label>
        <input type="checkbox" id="zebraToggle">
        
        <label for="zebraThresholdSlider" style="margin-left: 10px;">é–¾å€¤:</label>
        <input type="range" id="zebraThresholdSlider" value="90" min="0" max="100" step="1">
        <input type="number" id="zebraThresholdNumber" value="90" min="0" max="100" step="1">
        <span>%</span>
    </div>

    <p class="hist-label">ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ </p>
    <canvas id="histogramCanvas"></canvas>
</div>


<div class="right-panel">

    <div class="result-item" data-copy-target="blackRatio">
        <span class="result-label">é»’ã®å‰²åˆ:</span>
        <span class="result-value" id="blackRatioValue">--</span>
    </div>
    <div class="result-item" data-copy-target="whiteRatio">
        <span class="result-label">ç™½ã®å‰²åˆ:</span>
        <span class="result-value" id="whiteRatioValue">--</span>
    </div>
    <div class="result-item" data-copy-target="lightColor">
        <span class="result-label">æœ€ã‚‚æ˜ã‚‹ã„è‰²:</span>
        <span class="result-value" id="lightColorValue">#FFFFFF</span>
        <div class="color-swatch" id="lightColorSwatch"></div>
    </div>
    <div class="result-item" data-copy-target="darkColor">
        <span class="result-label">æœ€ã‚‚æš—ã„è‰²:</span>
        <span class="result-value" id="darkColorValue">#000000</span>
        <div class="color-swatch" id="darkColorSwatch"></div>
    </div>
    <div class="result-item" data-copy-target="contrastRatio">
        <span class="result-label">ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆæ¯”:</span>
        <span class="result-value" id="contrastRatioValue">--:1</span>
    </div>

    <div class="waveform-container">
        <div class="waveform-header">
            <span class="hist-label">æ³¢å½¢ãƒ¢ãƒ‹ã‚¿ãƒ¼</span>
            <div>
                <input type="radio" id="waveModeLuma" name="waveMode" value="Luma" checked>
                <label for="waveModeLuma">è¼åº¦</label>
                <input type="radio" id="waveModeRGB" name="waveMode" value="RGB">
                <label for="waveModeRGB">RGB</label>
            </div>
        </div>
        <canvas id="waveformCanvas"></canvas>
    </div>

    <div id="vectorscopeCard">
        <p class="hist-label" style="margin-top: 0; padding-top: 0; font-size: 16px;">ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ— (Cr/Cb)</p>
        <div id="vectorscopeWrapper">
            <canvas id="vectorscopeCanvas"></canvas>
        </div>
        <div class="scope-data-display">
            <div class="scope-data-item">
                <span class="scope-data-label">R-Y (Cr) Max</span>
                <span class="scope-data-value" id="crMaxValue">--</span>
            </div>
            <div class="scope-data-item">
                <span class="scope-data-label">B-Y (Cb) Max</span>
                <span class="scope-data-value" id="cbMaxValue">--</span>
            </div>
            <div class="scope-data-item">
                <span class="scope-data-label">Saturation Max</span>
                <span class="scope-data-value" id="satMaxValue">--</span>
            </div>
        </div>
    </div>

    <div id="processedImagesArea">
        <button id="prevProcessedImage" class="nav-button prev">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
        </button>
        
        <div id="processedImagesViewport">
            <div id="processedImagesWrapper">
                <div class="processed-image-card">
                    <canvas id="binaryCanvas" data-filename="binary_image.png"></canvas>
                    <p>äºŒå€¤åŒ–ç”»åƒ</p>
                </div>
                <div class="processed-image-card">
                    <canvas id="grayscaleCanvas" data-filename="grayscale_image.png"></canvas>
                    <p>è¼åº¦ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«</p>
                </div>
                <div class="processed-image-card">
                    <canvas id="saturationGrayscaleCanvas" data-filename="saturation_grayscale_image.png"></canvas>
                    <p>å½©åº¦ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«</p>
                </div>
                <div class="processed-image-card">
                    <canvas id="luminosityGrayscaleCanvas" data-filename="luminosity_grayscale_image.png"></canvas>
                    <p>æ˜åº¦ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«</p>
                </div>
            </div>
        </div>

        <button id="nextProcessedImage" class="nav-button next">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
        </button>
    </div>
    </div>
</div>

<footer>
<p>Created by Sabiasagi</p>
</footer>

<div id="eyedropperInfo">
    <div class="info-line">
        <span class="info-label">POS:</span>
        <span class="info-value" id="spotPos">--</span>
    </div>
    <div class="info-line">
        <span class="info-label">HEX:</span>
        <span class="info-value" id="spotHex">--</span>
    </div>
    <div class="info-line">
        <span class="info-label">RGB:</span>
        <span class="info-value" id="spotRGB">--</span>
    </div>
    <div class="info-line">
        <span class="info-label">LUM:</span>
        <span class="info-value" id="spotLum">--</span>
    </div>
</div>

<div id="copyTooltip" class="copy-tooltip">ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼</div>

<script>
// --- 1. å¤‰æ•°å®šç¾©ã¨åˆæœŸè¨­å®š ---
const DOM = {
initialDropArea: document.getElementById('initialDropArea'),
initialFileInput: document.getElementById('initialFileInput'),
analysisContainer: document.getElementById('analysisContainer'),
resultImagePreview: document.getElementById('resultImagePreview'), 
imagePlaceholder: document.getElementById('imagePlaceholder'),
histogramCanvas: document.getElementById('histogramCanvas'),
binaryCanvas: document.getElementById('binaryCanvas'),
grayscaleCanvas: document.getElementById('grayscaleCanvas'),
saturationGrayscaleCanvas: document.getElementById('saturationGrayscaleCanvas'),
luminosityGrayscaleCanvas: document.getElementById('luminosityGrayscaleCanvas'),
vectorscopeCanvas: document.getElementById('vectorscopeCanvas'), 
copyTooltip: document.getElementById('copyTooltip'),
values: {
blackRatio: document.getElementById('blackRatioValue'),
whiteRatio: document.getElementById('whiteRatioValue'),
lightColor: document.getElementById('lightColorValue'),
darkColor: document.getElementById('darkColorValue'),
contrastRatio: document.getElementById('contrastRatioValue')
},
swatches: {
lightColor: document.getElementById('lightColorSwatch'),
darkColor: document.getElementById('darkColorSwatch')
},
scopeValues: {
    crMax: document.getElementById('crMaxValue'),
    cbMax: document.getElementById('cbMaxValue'),
    satMax: document.getElementById('satMaxValue')
},
// ã‚¼ãƒ–ãƒ©DOM
zebraControls: document.getElementById('zebraControls'),
zebraToggle: document.getElementById('zebraToggle'),
zebraThresholdSlider: document.getElementById('zebraThresholdSlider'),
zebraThresholdNumber: document.getElementById('zebraThresholdNumber'),
// ã‚¹ãƒã‚¤ãƒˆ
eyedropperInfo: document.getElementById('eyedropperInfo'),
spotPos: document.getElementById('spotPos'),
spotHex: document.getElementById('spotHex'),
spotRGB: document.getElementById('spotRGB'),
spotLum: document.getElementById('spotLum'),
// æ³¢å½¢
waveformCanvas: document.getElementById('waveformCanvas'),
waveModeLuma: document.getElementById('waveModeLuma'),
waveModeRGB: document.getElementById('waveModeRGB'),

// â˜… ã‚¹ãƒ©ã‚¤ãƒ‰æ©Ÿèƒ½ç”¨ã®DOMè¦ç´ 
processedImagesWrapper: document.getElementById('processedImagesWrapper'),
prevProcessedImageButton: document.getElementById('prevProcessedImage'),
nextProcessedImageButton: document.getElementById('nextProcessedImage'),
};

// ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let currentImage = null; // ç”»åƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
let currentImageData = null; // ãƒ•ãƒ«è§£åƒåº¦ã®ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ (ImageData)
let previewCtx = DOM.resultImagePreview.getContext('2d');

// â˜… ã‚¹ãƒ©ã‚¤ãƒ‰æ©Ÿèƒ½ç”¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let currentProcessedImageIndex = 0; // ç¾åœ¨è¡¨ç¤ºã—ã¦ã„ã‚‹ç”»åƒã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
let processedImageCards = []; // ã‚«ãƒ¼ãƒ‰è¦ç´ ã®é…åˆ—


// --- 2. ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ç™»éŒ² ---
// ãƒ‰ãƒ­ãƒƒãƒ—ã‚¨ãƒªã‚¢
DOM.initialDropArea.addEventListener('click', () => DOM.initialFileInput.click());
DOM.initialFileInput.addEventListener('change', e => {
if (e.target.files.length > 0) handleFile(e.target.files[0]);
});
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
DOM.initialDropArea.addEventListener(eventName, preventDefaults, false);
});
DOM.initialDropArea.addEventListener('dragenter', () => DOM.initialDropArea.classList.add('highlight'), false);
DOM.initialDropArea.addEventListener('dragleave', () => DOM.initialDropArea.classList.remove('highlight'), false);
DOM.initialDropArea.addEventListener('drop', handleDrop, false);

function preventDefaults(e) {
e.preventDefault();
e.stopPropagation();
}

function handleDrop(e) {
const files = e.dataTransfer.files;
if (files.length > 0) {
DOM.initialDropArea.classList.remove('highlight');
handleFile(files[0]);
}
}

// ã‚³ãƒ”ãƒ¼æ©Ÿèƒ½
document.querySelectorAll('.result-item').forEach(item => {
item.addEventListener('click', copyTextToClipboard);
});

// ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½
[DOM.binaryCanvas, DOM.grayscaleCanvas, DOM.saturationGrayscaleCanvas, DOM.luminosityGrayscaleCanvas].forEach(canvas => {
canvas.addEventListener('click', () => downloadCanvasImage(canvas, canvas.dataset.filename));
});

// ã‚¼ãƒ–ãƒ©ï¼ˆã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨æ•°å€¤å…¥åŠ›ã®é€£å‹•ï¼‰
DOM.zebraToggle.addEventListener('change', onZebraChange);
DOM.zebraThresholdSlider.addEventListener('input', onZebraSliderChange);
DOM.zebraThresholdNumber.addEventListener('input', onZebraNumberChange);

function onZebraSliderChange() {
    DOM.zebraThresholdNumber.value = DOM.zebraThresholdSlider.value;
    onZebraChange();
}
function onZebraNumberChange() {
    let val = parseInt(DOM.zebraThresholdNumber.value, 10);
    if (isNaN(val)) val = 0;
    if (val < 0) val = 0;
    if (val > 100) val = 100;
    DOM.zebraThresholdNumber.value = val;
    DOM.zebraThresholdSlider.value = val;
    onZebraChange();
}

// ã‚¹ãƒã‚¤ãƒˆ
DOM.resultImagePreview.addEventListener('mousemove', handlePreviewMouseMove);
DOM.resultImagePreview.addEventListener('mouseleave', handlePreviewMouseLeave);
// æ³¢å½¢
DOM.waveModeLuma.addEventListener('change', onWaveModeChange);
DOM.waveModeRGB.addEventListener('change', onWaveModeChange);

// â˜… ã‚¹ãƒ©ã‚¤ãƒ‰ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
DOM.prevProcessedImageButton.addEventListener('click', () => navigateProcessedImages(-1));
DOM.nextProcessedImageButton.addEventListener('click', () => navigateProcessedImages(1));


// --- 3. ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ ---

function handleFile(file) {
if (!file.type.startsWith('image/')) return;

const reader = new FileReader();
reader.onload = (e) => {
const img = new Image();
img.onload = () => {
    currentImage = img; 

    // UIåˆ‡ã‚Šæ›¿ãˆ
    DOM.initialDropArea.style.display = 'none';
    DOM.imagePlaceholder.style.display = 'none';
    DOM.resultImagePreview.style.display = 'block';
    DOM.zebraControls.style.display = 'flex'; 

    DOM.analysisContainer.style.opacity = '0';
    DOM.analysisContainer.style.display = 'grid';
    setTimeout(() => { DOM.analysisContainer.style.opacity = '1'; }, 50);

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼Canvasã«ç”»åƒã‚’æç”» (é«˜DPIå¯¾å¿œ)
    drawPreviewCanvas();
    
    // è§£æã‚’å®Ÿè¡Œ (ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ä¿å­˜)
    analyzeAndDisplayResults(img);

    // â˜… ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼æ©Ÿèƒ½ã®åˆæœŸåŒ–
    processedImageCards = Array.from(DOM.processedImagesWrapper.children);
    currentProcessedImageIndex = 0; 
    updateProcessedImageDisplay(); 
};
img.src = e.target.result;
};
reader.readAsDataURL(file);
}

// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼Canvasã«æç”»ã™ã‚‹é–¢æ•° (â˜…ä¿®æ­£: é«˜DPIå¯¾å¿œ)
function drawPreviewCanvas() {
    if (!currentImage || !previewCtx) return;
    const canvas = DOM.resultImagePreview;
    
    // ãƒ‡ãƒã‚¤ã‚¹ãƒ”ã‚¯ã‚»ãƒ«æ¯”ã‚’å–å¾—
    const dpr = window.devicePixelRatio || 1; 
    
    // CSSã®ã‚µã‚¤ã‚ºã‚’å–å¾—
    const cssWidth = canvas.offsetWidth;
    const cssHeight = (currentImage.height / currentImage.width) * cssWidth;
    
    // Canvasã®æç”»ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã‚’è¨­å®š (DPIã‚’è€ƒæ…®)
    canvas.width = cssWidth * dpr;
    canvas.height = cssHeight * dpr;
    
    // Canvasã®è¡¨ç¤ºã‚µã‚¤ã‚º (CSSã‚µã‚¤ã‚º) ã‚’è¨­å®š
    canvas.style.width = `${cssWidth}px`;
    canvas.style.height = `${cssHeight}px`;
    
    // æç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
    previewCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // ç”»åƒã‚’æç”»
    previewCtx.imageSmoothingEnabled = true; // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°æœ‰åŠ¹åŒ–
    previewCtx.drawImage(currentImage, 0, 0, cssWidth, cssHeight);

    // æç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ (ã‚¼ãƒ–ãƒ©ãªã©ã®æç”»ã«å½±éŸ¿ã—ãªã„ã‚ˆã†ã«)
    previewCtx.setTransform(1, 0, 0, 1, 0, 0); 
}

function analyzeAndDisplayResults(img) {
// ãƒ•ãƒ«è§£åƒåº¦ã®ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ä¿å­˜
const tempCanvas = document.createElement('canvas');
const tempCtx = tempCanvas.getContext('2d');
tempCanvas.width = img.width;
tempCanvas.height = img.height;
tempCtx.drawImage(img, 0, 0);

currentImageData = tempCtx.getImageData(0, 0, img.width, img.height);
const data = currentImageData.data;

// --- ã“ã“ã‹ã‚‰æ—¢å­˜ã®è§£æãƒ­ã‚¸ãƒƒã‚¯ ---
const histogram = new Array(256).fill(0);
let minLum = 256, maxLum = -1;
let minColor = [0,0,0], maxColor = [255,255,255];
let maxCr = 0, maxCb = 0, maxSat = 0; 

for (let i = 0; i < data.length; i += 4) {
const r = data[i], g = data[i+1], b = data[i+2];
const rNorm = r / 255, gNorm = g / 255, bNorm = b / 255; 
const lum = Math.round(0.299*r + 0.587*g + 0.114*b); 
histogram[lum]++;

if (lum < minLum) { minLum = lum; minColor = [r,g,b]; }
if (lum > maxLum) { maxLum = lum; maxColor = [r,g,b]; }

// YCrCbã®è¨ˆç®—
const yNorm = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
const cbNorm = bNorm - yNorm; // B-Y
const crNorm = rNorm - yNorm; // R-Y
const satNorm = Math.sqrt(crNorm * crNorm + cbNorm * cbNorm); // å½©åº¦

maxCr = Math.max(maxCr, Math.abs(crNorm));
maxCb = Math.max(maxCb, Math.abs(cbNorm));
maxSat = Math.max(maxSat, satNorm);

}

const threshold = otsuThreshold(histogram, img.width * img.height);

let black = 0, white = 0;
for (let i = 0; i < 256; i++) {
if (i < threshold) black += histogram[i];
else white += histogram[i];
}

const totalPixels = black + white;
const blackRatio = (black / totalPixels * 100).toFixed(2);
const whiteRatio = (white / totalPixels * 100).toFixed(2);

const darkestHex = rgbToHex(...minColor);
const lightestHex = rgbToHex(...maxColor);
const contrast = getContrastRatio(lightestHex, darkestHex);

// UIã®æ›´æ–°
DOM.values.blackRatio.textContent = `${blackRatio}%`;
DOM.values.whiteRatio.textContent = `${whiteRatio}%`;
DOM.values.lightColor.textContent = lightestHex;
DOM.values.darkColor.textContent = darkestHex;
DOM.swatches.lightColor.style.backgroundColor = lightestHex;
DOM.swatches.darkColor.style.backgroundColor = darkestHex;
DOM.values.contrastRatio.textContent = `${contrast.toFixed(2)}:1`;

DOM.scopeValues.crMax.textContent = maxCr.toFixed(4);
DOM.scopeValues.cbMax.textContent = maxCb.toFixed(4);
DOM.scopeValues.satMax.textContent = maxSat.toFixed(4);

// æç”»
animateHistogram(DOM.histogramCanvas, histogram, threshold); // â˜…ä¿®æ­£: é«˜DPIå¯¾å¿œ
drawVectorscope(DOM.vectorscopeCanvas, data); // â˜…ä¿®æ­£: å°å‹åŒ–ã¨æƒ…å ±è¿½åŠ 

// â˜… å…¨ã¦ã®ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æç”»
drawProcessedImage(DOM.binaryCanvas, img, threshold, 'binary');
drawProcessedImage(DOM.grayscaleCanvas, img, threshold, 'grayscale');
drawProcessedImage(DOM.saturationGrayscaleCanvas, img, threshold, 'saturation');
drawProcessedImage(DOM.luminosityGrayscaleCanvas, img, threshold, 'luminosity');


// æ³¢å½¢ãƒ¢ãƒ‹ã‚¿ãƒ¼ã®åˆå›æç”»ã‚’ã‚ãšã‹ã«é…å»¶ã•ã›ã‚‹
setTimeout(() => {
    drawWaveform();
}, 100); 

// ã‚¼ãƒ–ãƒ©ãŒã‚‚ã—ONãªã‚‰åˆå›æç”»
onZebraChange();
}

// â˜… å‡¦ç†æ¸ˆã¿ç”»åƒã®æç”» (ãƒ•ãƒ«è§£åƒåº¦ + æ–°ãƒ¢ãƒ¼ãƒ‰)
function drawProcessedImage(canvas, originalImg, threshold, mode) {
    // å…ƒç”»åƒã®è§£åƒåº¦ã§Canvasã‚’è¨­å®š
    canvas.width = originalImg.width;
    canvas.height = originalImg.height;

    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false; 
    ctx.drawImage(originalImg, 0, 0, originalImg.width, originalImg.height); 

    const imageData = ctx.getImageData(0, 0, originalImg.width, originalImg.height);
    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i+1], b = data[i+2];
        let color;

        if (mode === 'binary' || mode === 'grayscale') {
            const lum = Math.round(0.299*r + 0.587*g + 0.114*b); // è¼åº¦ (Luma)
            if (mode === 'binary') {
                color = lum < threshold ? 0 : 255;
            } else {
                color = lum;
            }
        } else {
            // HSL Calculation for Saturation and Luminosity (Lightness)
            const rN = r / 255, gN = g / 255, bN = b / 255;
            const max = Math.max(rN, gN, bN), min = Math.min(rN, gN, bN);
            let s, l = (max + min) / 2;

            if (max === min) {
                s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            }

            if (mode === 'saturation') {
                color = Math.round(s * 255);
            } else if (mode === 'luminosity') {
                color = Math.round(l * 255); // æ˜åº¦ (Lightness)
            }
        }
        data[i] = data[i+1] = data[i+2] = color;
    }
    // ãƒ•ãƒ«è§£åƒåº¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’Canvasã«æˆ»ã™
    ctx.putImageData(imageData, 0, 0);
}


// --- 4. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° ---

function otsuThreshold(hist, total) {
let sum = 0;
for (let i = 0; i < 256; i++) sum += i * hist[i];

let sumB = 0, wB = 0, wF = 0, varMax = 0, threshold = 0;

for (let i = 0; i < 256; i++) {
wB += hist[i];
if (wB === 0) continue;
wF = total - wB;
if (wF === 0) break;
sumB += i * hist[i];

const mB = sumB / wB;
const mF = (sum - sumB) / wF;
const varBetween = wB * wF * (mB - mF) ** 2;

if (varBetween > varMax) {
varMax = varBetween;
threshold = i;
}
}
return threshold;
}

// ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ (â˜…ä¿®æ­£: é«˜DPIå¯¾å¿œ)
function animateHistogram(canvas, histogram, threshold) {
    const ctx = canvas.getContext('2d');
    
    // é«˜DPIå¯¾å¿œ
    const dpr = window.devicePixelRatio || 1;
    
    const cssWidth = canvas.offsetWidth;
    const cssHeight = canvas.offsetHeight; 
    
    canvas.width = cssWidth * dpr; // æç”»ãƒãƒƒãƒ•ã‚¡ã‚’é«˜DPIã«è¨­å®š
    canvas.height = cssHeight * dpr; 
    
    const w = canvas.width; // å†…éƒ¨æç”»å¹…
    const scaleHeight = 15 * dpr; // ã‚¹ã‚±ãƒ¼ãƒ«ã‚‚DPIå¯¾å¿œ
    const graphHeight = canvas.height - scaleHeight; 

    const sortedHist = [...histogram].filter(val => val > 0).sort((a, b) => a - b);
    let max;
    if (sortedHist.length > 0) {
        const percentileIndex = Math.floor(sortedHist.length * 0.99);
        max = sortedHist[percentileIndex];
    } else {
        max = 1; 
    }
    if (max < 10) { 
        max = Math.max(...histogram, 1);
    }
    
    const animationDuration = 800;
    const startTime = performance.now();

    function drawFrame(currentTime) {
        const elapsedTime = currentTime - startTime;
        const animationProgress = Math.min(1, elapsedTime / animationDuration);

        ctx.clearRect(0, 0, w, canvas.height); 

        // æç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        ctx.beginPath();
        ctx.moveTo(0, graphHeight / dpr); 

        const currentDrawRange = w * animationProgress;

        for (let i = 0; i < currentDrawRange; i++) {
            const histIndex = Math.floor(i / (w / dpr) * 256); 
            const histValue = histogram[histIndex] || 0; 
            const barHeight = (histValue / max) * (graphHeight / dpr); 
            const x = i / dpr; 
            const y = (graphHeight / dpr) - barHeight; 

            if (i > 0) {
                const prevX = (i - 1) / dpr;
                const prevHistIndex = Math.floor(prevX / (w / dpr) * 256);
                const prevY = (graphHeight / dpr) - (histogram[prevHistIndex] / max) * (graphHeight / dpr);
                ctx.bezierCurveTo(prevX + (x - prevX) * 0.5, prevY, x - (x - prevX) * 0.5, y, x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.lineTo(currentDrawRange / dpr, graphHeight / dpr); 
        
        ctx.fillStyle = 'var(--accent-color)';
        ctx.fill();
        ctx.strokeStyle = 'var(--accent-color)';
        ctx.lineWidth = 1;
        ctx.stroke();

        const grad = ctx.createLinearGradient(0, 0, w / dpr, 0); 
        grad.addColorStop(0, "#000000");
        grad.addColorStop(1, "#FFFFFF");
        ctx.fillStyle = grad;
        ctx.fillRect(0, graphHeight / dpr, w / dpr, scaleHeight / dpr); 

        if (animationProgress === 1) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; 
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const thresholdX = threshold / 256 * (w / dpr); 
            ctx.moveTo(thresholdX, 0);
            ctx.lineTo(thresholdX, (graphHeight + scaleHeight) / dpr);
            ctx.stroke();
        }
        
        // æç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        if (animationProgress < 1) {
            requestAnimationFrame(drawFrame);
        }
    }

    requestAnimationFrame(drawFrame);
}


// ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ— (â˜…ä¿®æ­£: å°å‹åŒ–ã¨æƒ…å ±è¿½åŠ )
function drawVectorscope(canvas, pixelData) {
    const ctx = canvas.getContext('2d');
    const size = 200; // CSSã¨åˆã‚ã›ã‚‹
    canvas.width = size;
    canvas.height = size;
    const center = size / 2;
    const radius = size / 2 - 15; // ãƒãƒ¼ã‚«ãƒ¼ã‚„ãƒ†ã‚­ã‚¹ãƒˆã®ä½™ç™½
    const numPixels = pixelData.length / 4;
    const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--scope-grid-color').trim();

    // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢
    ctx.fillStyle = 'var(--scope-bg-color)'; 
    ctx.fillRect(0, 0, size, size);

    // ã‚°ãƒªãƒƒãƒ‰ç·š
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(center, 0); ctx.lineTo(center, size); // å‚ç›´ç·š (Cbè»¸)
    ctx.moveTo(0, center); ctx.lineTo(size, center); // æ°´å¹³ç·š (Crè»¸)
    ctx.stroke();

    // åŒå¿ƒå††
    ctx.beginPath();
    ctx.arc(center, center, radius * 0.66, 0, 2 * Math.PI); 
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(center, center, radius, 0, 2 * Math.PI);
    ctx.stroke();

    // è§’åº¦ç›®ç››ã‚Š
    for (let i = 0; i < 360; i += 30) {
        const rad = i * (Math.PI / 180);
        const startR = radius * 1.05;
        const endR = radius * 1.15;
        const x1 = center + startR * Math.sin(rad);
        const y1 = center - startR * Math.cos(rad);
        const x2 = center + endR * Math.sin(rad);
        const y2 = center - endR * Math.cos(rad);
        ctx.lineWidth = i % 90 === 0 ? 1.5 : 1;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }

    // â˜… ä¸»è¦ãªè‰²ç›¸ã®ãƒãƒ¼ã‚«ãƒ¼ã¨ãƒ†ã‚­ã‚¹ãƒˆ (R, MG, B, CY, G, YL)
    const primaryColors = [
        { label: 'R', angle: 330, color: '#FF0000', textOffset: 15 }, 
        { label: 'MG', angle: 30, color: '#FF00FF', textOffset: 15 }, 
        { label: 'B', angle: 90, color: '#0000FF', textOffset: 15 },  
        { label: 'CY', angle: 150, color: '#00FFFF', textOffset: 15 }, 
        { label: 'G', angle: 210, color: '#00FF00', textOffset: 15 }, 
        { label: 'YL', angle: 270, color: '#FFFF00', textOffset: 15 } 
    ];
    
    // â˜… è¿½åŠ ã®è§’åº¦æƒ…å ± (3æšç›®ã®ç”»åƒã‚’å‚è€ƒã«)
    const additionalAngles = [
        { angle: 60.8, text: '60.8Â°', align: 'left' },
        { angle: 103.4, text: '103.4Â°', align: 'left' },
        { angle: 123, text: '123Â°', align: 'left' },
        { angle: 167.1, text: '167.1Â°', align: 'left' },
        { angle: 213, text: '213Â°', align: 'left' },
        { angle: 240.8, text: '240.8Â°', align: 'right' },
        { angle: 283.4, text: '283.4Â°', align: 'right' },
        { angle: 303, text: '303Â°', align: 'right' },
        { angle: 33, text: '33Â°', align: 'right' },
        { angle: 347.1, text: '347.1Â°', align: 'right' }
    ];

    primaryColors.forEach(pc => {
        const rad = pc.angle * (Math.PI / 180);
        const markerRadius = radius * 0.8; 
        const x_marker = center + markerRadius * Math.sin(rad);
        const y_marker = center - markerRadius * Math.cos(rad);
        
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 1;

        // å››è§’ã„ãƒãƒ¼ã‚«ãƒ¼ã®æç”»
        const boxSize = 10; 
        ctx.strokeRect(x_marker - boxSize/2, y_marker - boxSize/2, boxSize, boxSize);

        // ãƒ†ã‚­ã‚¹ãƒˆãƒ©ãƒ™ãƒ«ã®æç”» (è‰²ç›¸å)
        ctx.fillStyle = gridColor;
        ctx.font = '10px var(--font-futura)'; 
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const labelRad = (pc.angle - 90) * (Math.PI / 180); 
        const labelDist = radius + pc.textOffset; 
        const x_label = center + labelDist * Math.cos(labelRad);
        const y_label = center + labelDist * Math.sin(labelRad);

        // ãƒ†ã‚­ã‚¹ãƒˆã®ä½ç½®èª¿æ•´
        ctx.save();
        ctx.translate(x_label, y_label);
        ctx.rotate(labelRad + Math.PI / 2); 
        ctx.fillText(pc.label, 0, 0); 
        ctx.restore();
    });

    // â˜… è¿½åŠ ã®è§’åº¦ãƒ†ã‚­ã‚¹ãƒˆæç”»
    additionalAngles.forEach(item => {
        const rad = (item.angle - 90) * (Math.PI / 180); 
        const labelDist = radius + 25; 
        const x_label = center + labelDist * Math.cos(rad);
        const y_label = center + labelDist * Math.sin(rad);

        ctx.fillStyle = gridColor;
        ctx.font = '10px var(--font-futura)';
        ctx.textAlign = item.align === 'left' ? 'left' : 'right'; 
        ctx.textBaseline = 'middle';

        ctx.save();
        ctx.translate(x_label, y_label);
        ctx.rotate(rad + Math.PI / 2);
        ctx.fillText(item.text, 0, 0); 
        ctx.restore();
    });

    // â˜… è»¸ãƒ©ãƒ™ãƒ« (Cr, Cb) ã®è¿½åŠ 
    ctx.fillStyle = gridColor;
    ctx.font = '10px var(--font-futura)';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('B-Y (Cb)', center, size - 10); 
    ctx.fillText('R-Y (Cr)', size - 10, center); 

    // ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã®ãƒ—ãƒ­ãƒƒãƒˆ
    ctx.globalCompositeOperation = 'screen'; 
    const maxChrominance = 0.5; 
    const plotRadius = radius; 
    const skip = Math.max(1, Math.floor(numPixels / 50000)); 
    
    for (let i = 0; i < pixelData.length; i += 4 * skip) {
        const r = pixelData[i] / 255;
        const g = pixelData[i+1] / 255;
        const b = pixelData[i+2] / 255;
        
        const yNorm = 0.299 * r + 0.587 * g + 0.114 * b;
        const cbNorm = b - yNorm; 
        const crNorm = r - yNorm; 
        
        const plotCb = cbNorm * (plotRadius / maxChrominance);
        const plotCr = crNorm * (plotRadius / maxChrominance);
        
        const plotX = center + plotCb; 
        const plotY = center - plotCr; 

        const dx = plotX - center;
        const dy = plotY - center;
        if (dx * dx + dy * dy <= plotRadius * plotRadius * 1.1) { 
            const hue = (Math.atan2(-crNorm, cbNorm) * (180 / Math.PI) + 360) % 360; 
            const sat = Math.sqrt(crNorm * crNorm + cbNorm * cbNorm) / maxChrominance; 
            
            const lum = yNorm * 100; 
            const lightness = Math.max(10, Math.min(90, lum)); 
            
            ctx.fillStyle = `hsl(${hue}, ${sat * 100}%, ${lightness}%)`; 
            ctx.fillRect(plotX, plotY, 1.5, 1.5); 
        }
    }
    ctx.globalCompositeOperation = 'source-over'; 
}


function rgbToHex(r,g,b) {
return "#" + [r,g,b].map(x => x.toString(16).padStart(2, '0')).join('').toUpperCase();
}

function getLuminance(hex) {
const r = parseInt(hex.slice(1, 3), 16) / 255;
const g = parseInt(hex.slice(3, 5), 16) / 255;
const b = parseInt(hex.slice(5, 7), 16) / 255;
const toLinear = (c) => (c <= 0.03928) ? c / 12.92 : ((c + 0.055) / 1.055) ** 2.4;
const L = 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
return L;
}

function getContrastRatio(hex1, hex2) {
const L1 = getLuminance(hex1);
const L2 = getLuminance(hex2);
return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
}

// --- 5. ã‚³ãƒ”ãƒ¼/ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ ---

function copyTextToClipboard(e) {
const item = e.currentTarget;
const targetId = item.dataset.copyTarget;
let textToCopy = '';
switch(targetId) {
case 'blackRatio': textToCopy = DOM.values.blackRatio.textContent.replace('%', ''); break;
case 'whiteRatio': textToCopy = DOM.values.whiteRatio.textContent.replace('%', ''); break;
case 'lightColor': textToCopy = DOM.values.lightColor.textContent; break;
case 'darkColor': textToCopy = DOM.values.darkColor.textContent; break;
case 'contrastRatio': textToCopy = DOM.values.contrastRatio.textContent.replace(':1', ''); break;
}
if (textToCopy) {
navigator.clipboard.writeText(textToCopy).then(() => {
showTooltip(e.clientX, e.clientY);
}).catch(err => console.error('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ:', err));
}
}

let tooltipTimeout;
function showTooltip(x, y) {
DOM.copyTooltip.style.left = `${x + 10}px`;
DOM.copyTooltip.style.top = `${y - 20}px`;
DOM.copyTooltip.classList.add('show');
clearTimeout(tooltipTimeout);
tooltipTimeout = setTimeout(() => {
DOM.copyTooltip.classList.remove('show');
}, 1500);
}

function downloadCanvasImage(canvas, filename) {
const link = document.createElement('a');
link.download = filename || 'image.png';
canvas.toBlob((blob) => {
link.href = URL.createObjectURL(blob);
link.click();
URL.revokeObjectURL(link.href);
}, 'image/png');
}


// --- 6. â˜…â˜…â˜… æ–°æ©Ÿèƒ½ã®å®Ÿè£… â˜…â˜…â˜… ---

// ã‚¹ãƒã‚¤ãƒˆ: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸Šã‚’ãƒã‚¦ã‚¹ç§»å‹•
function handlePreviewMouseMove(e) {
    if (!currentImageData || !currentImage) return;

    const canvas = DOM.resultImagePreview;
    const rect = canvas.getBoundingClientRect();
    
    // é«˜DPIã‚’è€ƒæ…®ã—ãŸã‚¹ã‚±ãƒ¼ãƒ«ã‚’å–å¾—
    const dpr = window.devicePixelRatio || 1;
    const scaleX = currentImageData.width / (canvas.width / dpr);
    const scaleY = currentImageData.height / (canvas.height / dpr);
    
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const imgX = Math.floor(x * scaleX);
    const imgY = Math.floor(y * scaleY);

    if (imgX < 0 || imgX >= currentImageData.width || imgY < 0 || imgY >= currentImageData.height) {
        handlePreviewMouseLeave();
        return;
    }

    const index = (imgY * currentImageData.width + imgX) * 4;
    const data = currentImageData.data;
    const r = data[index];
    const g = data[index+1];
    const b = data[index+2];
    
    const lum = Math.round(0.299*r + 0.587*g + 0.114*b);
    
    DOM.spotPos.textContent = `${imgX}, ${imgY}`;
    DOM.spotHex.textContent = rgbToHex(r, g, b);
    DOM.spotRGB.textContent = `${r}, ${g}, ${b}`;
    DOM.spotLum.textContent = lum;
    
    DOM.eyedropperInfo.style.left = `${e.clientX + 15}px`;
    DOM.eyedropperInfo.style.top = `${e.clientY}px`;
    DOM.eyedropperInfo.style.display = 'block';
}

// ã‚¹ãƒã‚¤ãƒˆ: ãƒã‚¦ã‚¹ãŒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‹ã‚‰å¤–ã‚ŒãŸ
function handlePreviewMouseLeave() {
    DOM.eyedropperInfo.style.display = 'none';
}

// ã‚¼ãƒ–ãƒ©: ãƒˆã‚°ãƒ«ã¾ãŸã¯é–¾å€¤ãŒå¤‰æ›´ã•ã‚ŒãŸ
function onZebraChange() {
    if (!currentImage) return;
    
    const thresholdValue = parseInt(DOM.zebraThresholdNumber.value, 10);
    
    if (DOM.zebraToggle.checked) {
        drawZebraPattern(thresholdValue);
    } else {
        drawPreviewCanvas(); // ã‚¼ãƒ–ãƒ©ã‚’æ¶ˆã—ã¦å…ƒã®ç”»åƒã‚’æç”»
    }
}

// ã‚¼ãƒ–ãƒ©: ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æç”»
function drawZebraPattern(thresholdValue) {
    if (!currentImageData || !previewCtx) return;

    drawPreviewCanvas(); 
    
    const canvas = DOM.resultImagePreview;
    const ctx = previewCtx;
    
    if (isNaN(thresholdValue)) return;
    
    const thresholdLuma = (thresholdValue / 100) * 255;
    
    // æç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒã‚¹ã‚±ãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€getImageDataã¯ãƒªã‚»ãƒƒãƒˆå¾Œã®ã‚µã‚¤ã‚ºã§å–å¾—
    const canvasImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const canvasData = canvasImageData.data;
    const canvasWidth = canvas.width;

    for (let i = 0; i < canvasData.length; i += 4) {
        const r = canvasData[i];
        const g = canvasData[i+1];
        const b = canvasData[i+2];
        
        const lum = 0.299*r + 0.587*g + 0.114*b;
        
        if (lum > thresholdLuma) {
            const y = Math.floor((i / 4) / canvasWidth);
            const x = (i / 4) % canvasWidth;
            
            if ((x + y) % 8 < 4) { 
                canvasData[i] = 255;   
                canvasData[i+1] = 0;   
                canvasData[i+2] = 0;   
                canvasData[i+3] = 200; 
            }
        }
    }
    // æç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆå¾Œã®putImageDataã§æç”»
    ctx.putImageData(canvasImageData, 0, 0);
}

// æ³¢å½¢: ãƒ¢ãƒ¼ãƒ‰ãŒå¤‰æ›´ã•ã‚ŒãŸ
function onWaveModeChange() {
    drawWaveform();
}

// æ³¢å½¢ãƒ¢ãƒ‹ã‚¿ãƒ¼ã‚’æç”»
function drawWaveform() {
    if (!currentImage) return;

    const canvas = DOM.waveformCanvas;
    const ctx = canvas.getContext('2d');
    const mode = DOM.waveModeLuma.checked ? 'Luma' : 'RGB';
    
    const w = canvas.offsetWidth;
    const h = 150; 
    canvas.width = w;
    canvas.height = h;

    const tempWaveCanvas = document.createElement('canvas');
    const tempWaveHeight = (currentImage.height / currentImage.width) * w;
    tempWaveCanvas.width = w;
    tempWaveCanvas.height = tempWaveHeight; 

    const tempWaveCtx = tempWaveCanvas.getContext('2d');
    
    tempWaveCtx.drawImage(currentImage, 0, 0, w, tempWaveHeight);
    const imageData = tempWaveCtx.getImageData(0, 0, w, tempWaveHeight);
    const data = imageData.data;

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, w, h);

    const lumaBins = new Uint8Array(w * 256); 
    const rBins = new Uint8Array(w * 256); 
    const gBins = new Uint8Array(w * 256); 
    const bBins = new Uint8Array(w * 256); 

    for (let i = 0; i < data.length; i += 4) {
        const x = Math.floor((i / 4) % w); 
        
        const r = data[i];
        const g = data[i+1];
        const b = data[i+2];
        const lum = Math.round(0.299*r + 0.587*g + 0.114*b);

        lumaBins[x * 256 + lum]++;
        rBins[x * 256 + r]++;
        gBins[x * 256 + g]++;
        bBins[x * 256 + b]++;
    }
    
    const accentColor = 'var(--accent-color)';
    
    if (mode === 'Luma') {
        const scalingMax = Math.max(1, Math.floor(tempWaveHeight / 10));
        drawWaveChannel(ctx, lumaBins, w, h, accentColor, scalingMax);
    } else { 
        ctx.globalCompositeOperation = 'lighter'; 
        
        const scalingMaxRGB = Math.max(1, Math.floor(tempWaveHeight / 20));
        drawWaveChannel(ctx, rBins, w, h, 'rgba(255, 0, 0, 0.7)', scalingMaxRGB);
        drawWaveChannel(ctx, gBins, w, h, 'rgba(0, 255, 0, 0.7)', scalingMaxRGB);
        drawWaveChannel(ctx, bBins, w, h, 'rgba(0, 0, 255, 0.7)', scalingMaxRGB);

        ctx.globalCompositeOperation = 'source-over'; 
    }
}

// æ³¢å½¢æç”»ã®ã‚µãƒ–é–¢æ•°
function drawWaveChannel(ctx, bins, w, h, color, scalingMax) {
    
    const hScale = h / 256; 

    for (let x = 0; x < w; x++) {
        for (let l = 0; l < 256; l++) { 
            const count = bins[x * 256 + l];
            if (count > 0) {
                const opacity = Math.min(1, (count / scalingMax) * 0.7 + 0.3);
                
                if (color.includes('rgba')) { 
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = color;
                } else { 
                    ctx.fillStyle = `rgba(185, 82, 130, ${opacity})`;
                }
                
                ctx.fillRect(x, h - (l * hScale) - 1, 1, 1); 
            }
        }
    }
    ctx.globalAlpha = 1.0; 
}

// ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼æ©Ÿèƒ½ã®é–¢æ•°

// å‡¦ç†æ¸ˆã¿ç”»åƒã®è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
function updateProcessedImageDisplay() {
    if (processedImageCards.length === 0) {
        processedImageCards = Array.from(DOM.processedImagesWrapper.children);
        if (processedImageCards.length === 0) return;
    }

    // 1æšã®ã‚«ãƒ¼ãƒ‰ã®å¹… (offsetWidth) ã‚’åŸºæº–ã«ã™ã‚‹
    const cardWidth = processedImageCards[0].offsetWidth;
    const offset = -currentProcessedImageIndex * cardWidth;
    
    DOM.processedImagesWrapper.style.transform = `translateX(${offset}px)`;

    // çŸ¢å°ãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
    DOM.prevProcessedImageButton.disabled = currentProcessedImageIndex === 0;
    DOM.nextProcessedImageButton.disabled = currentProcessedImageIndex === processedImageCards.length - 1;
}

// å‡¦ç†æ¸ˆã¿ç”»åƒã‚’ãƒŠãƒ“ã‚²ãƒ¼ãƒˆã™ã‚‹é–¢æ•°
function navigateProcessedImages(direction) {
    const newIndex = currentProcessedImageIndex + direction;
    
    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒç¯„å›²å†…ã‹ãƒã‚§ãƒƒã‚¯
    if (newIndex >= 0 && newIndex < processedImageCards.length) {
        currentProcessedImageIndex = newIndex;
        updateProcessedImageDisplay();
    }
}


</script>
</body>
</html>
