<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ç”»åƒã‚«ãƒ©ãƒ¼åˆ†æ</title>

<script>
// Typekit (ãƒ•ã‚©ãƒ³ãƒˆ) ã®èª­ã¿è¾¼ã¿
  (function(d) {
    var config = {
      kitId: 'ydf1tls',
      scriptTimeout: 3000,
      async: true
    },
    h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
  })(document);
</script>
<style>
:root {
/* --- ğŸ¨ ã‚«ãƒ©ãƒ¼è¨­å®š --- */
--bg-color: #dbdbd7; 	 /* å…¨ä½“ã®èƒŒæ™¯è‰² (æ·¡ã„ã‚°ãƒ¬ãƒ¼) */
--main-card-bg: #dbdbd7; 	 /* ã‚«ãƒ¼ãƒ‰ã®èƒŒæ™¯è‰² (èƒŒæ™¯ã¨åŒã˜) */
--text-color-primary: #111111; /* ãƒ¡ã‚¤ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®è‰² (é»’) */
--text-color-subtle: #111111; 	/* ã‚µãƒ–ãƒ†ã‚­ã‚¹ãƒˆã®è‰² (ã‚°ãƒ¬ãƒ¼) */
--accent-color: #b95282; 	 /* å¼·èª¿è‰² (ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚„ãƒ›ãƒãƒ¼) */
--scope-grid-color: #a77d54; /* ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®ã‚°ãƒªãƒƒãƒ‰è‰² (ã‚´ãƒ¼ãƒ«ãƒ‰ç³») */
--scope-bg-color: #000000; /* ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®èƒŒæ™¯è‰² (é»’) */

/* --- ğŸ“ ç½«ç·šãƒ»ãƒ‡ã‚¶ã‚¤ãƒ³è¨­å®š --- */
--border-color: #111111; 	 /* ç¸å–ã‚Šã®è‰² (é»’) */
--card-radius: 8px; 	 	/* ã‚«ãƒ¼ãƒ‰ã®è§’ä¸¸ã‚µã‚¤ã‚º */
--line-subtle: #111111; 	 	/* ç´°ã„ç·šã®è‰² */
--line-strong: #111111; 	 	/* å¼·èª¿ç·šã®è‰² */
--threshold-color: #FFFFFF; 	/* é–¾å€¤ã®è‰² */

/* --- ğŸ–‹ï¸ ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š --- */
--font-heading: 'futura-100-book', "dnp-shuei-gothic-gin-std", sans-serif;
--font-body: 'dnp-shuei-gothic-gin-std', 'futura-100-book', sans-serif;
--font-futura: 'futura-100-book', sans-serif; /* ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®è¨ˆæ¸¬å€¤ç”¨ */
}

body {
font-family: var(--font-body);
text-align: center;
background: var(--bg-color);
margin: 0;
padding: 60px 40px;
color: var(--text-color-primary);
min-height: 100vh;
box-sizing: border-box;
display: flex;
flex-direction: column;
align-items: center;
font-weight: 400; 
}

h2 {
font-size: 36px;
font-weight: 500; 
color: var(--text-color-primary);
margin-bottom: 5px;
font-family: var(--font-heading);
letter-spacing: 0.05em;
}

.sub-text {
color: var(--text-color-subtle);
font-size: 14px;
font-family: var(--font-body);
line-height: 1.7;
margin-bottom: 50px;
}

/* --- ãƒ‰ãƒ­ãƒƒãƒ—é ˜åŸŸ (åˆæœŸçŠ¶æ…‹) --- */
#initialDropArea {
position: relative;
width: 800px;
height: 450px;
background-color: var(--main-card-bg);
display: flex;
justify-content: center;
align-items: center;
margin: 0 auto;
cursor: pointer;
transition: background-color 0.3s ease, border-color 0.3s ease;

border: 1px solid var(--border-color);
border-radius: var(--card-radius);
}

#initialDropArea:hover, #initialDropArea.highlight {
background-color: #be7792; 
border-color: var(--accent-color); 
}

#initialDropArea p {
color: var(--text-color-primary);
font-size: 24px;
font-weight: 500;
font-family: var(--font-body);
background-color: transparent;
padding: 5px 15px;
border: 1px solid var(--text-color-primary);
line-height: 1;
}

#initialFileInput {
display: none;
}

/* --- è§£æçµæœã‚³ãƒ³ãƒ†ãƒŠ --- */
@keyframes fadeIn {
from { opacity: 0; transform: translateY(10px); }
to { opacity: 1; transform: translateY(0); }
}

#analysisContainer {
opacity: 0;
animation: fadeIn 0.8s ease-out forwards;
animation-delay: 0.1s;
width: 100%;
max-width: 1200px;
margin-top: 40px;
display: grid;
grid-template-columns: 1fr 1fr;
gap: 40px;
align-items: start;
}

/* å·¦å´ã®ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¨ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®ãƒ‘ãƒãƒ« */
.left-panel {
display: flex;
flex-direction: column;
background-color: var(--main-card-bg);
padding: 30px;
color: var(--text-color-primary);
text-align: left;

border: 1px solid var(--border-color);
border-radius: var(--card-radius);
}

#imagePlaceholder {
width: 100%;
aspect-ratio: 16 / 9;
background-color: #222222;
display: flex;
justify-content: center;
align-items: center;
font-size: 24px;
font-weight: 500;
color: var(--text-color-subtle);
margin-bottom: 20px;
}

/* <img> ã‹ã‚‰ <canvas> ã«å¤‰æ›´ */
#resultImagePreview {
width: 100%;
height: auto;
display: none;
margin-bottom: 20px;
border: none;
cursor: crosshair; /* ã‚¹ãƒã‚¤ãƒˆæ©Ÿèƒ½ã®ãŸã‚ã«ã‚«ãƒ¼ã‚½ãƒ«ã‚’å¤‰æ›´ */
}

/* â˜… ä¿®æ­£: ã‚¼ãƒ–ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« (ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼) ã®UI */
#zebraControls {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 14px;
    padding: 10px;
    border-top: 1px dashed var(--line-subtle);
    border-bottom: 1px dashed var(--line-subtle);
    gap: 10px;
    color: var(--text-color-primary);
}
#zebraControls label {
    margin-right: 5px;
    white-space: nowrap;
    color: var(--text-color-subtle);
}
#zebraControls input[type="range"] {
    flex-grow: 1;
    margin: 0 5px;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: var(--line-subtle);
    outline: none;
    opacity: 0.7;
    transition: opacity .2s;
    border-radius: 2px;
}
#zebraControls input[type="range"]:hover {
    opacity: 1;
}
#zebraControls input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--accent-color);
    cursor: pointer;
}
#zebraControls input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--accent-color);
    cursor: pointer;
}

#zebraControls input[type="number"] {
    width: 45px;
    font-family: var(--font-futura);
    text-align: center;
    border: 1px solid var(--line-subtle);
    background-color: var(--main-card-bg);
    color: var(--text-color-primary);
    padding: 3px 0;
    border-radius: 4px;
}
#zebraControls input[type="number"]:focus {
    outline: none;
    border-color: var(--accent-color);
}

#zebraControls input[type="checkbox"] {
    width: 16px;
    height: 16px;
    -webkit-appearance: none;
    appearance: none;
    border: 1px solid var(--line-subtle);
    border-radius: 3px;
    outline: none;
    cursor: pointer;
    background-color: var(--main-card-bg);
    position: relative;
    top: 2px;
}
#zebraControls input[type="checkbox"]:checked {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
}
#zebraControls input[type="checkbox"]:checked::after {
    content: 'âœ”';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #fff;
    font-size: 10px;
    font-weight: bold;
}


.hist-label {
font-size: 20px;
font-weight: 500;
margin-top: 30px;
margin-bottom: 15px;
padding-top: 15px;
text-align: center;
font-family: var(--font-heading);
}

#histogramCanvas {
width: 100%;
height: 120px;
display: block;
background-color: var(--main-card-bg);
}

/* å³å´ã®è§£æçµæœã¨ã‚³ãƒ”ãƒ¼ãƒœã‚¿ãƒ³ã®ãƒ‘ãƒãƒ« */
.right-panel {
display: flex;
flex-direction: column;
background-color: var(--bg-color); 
padding: 0;
color: var(--text-color-primary);
text-align: left;
}

.result-item {
display: flex;
align-items: center;
padding: 10px 0;
border-bottom: 1px solid var(--line-subtle);
cursor: pointer;
transition: background-color 0.2s ease;
}

.result-item:hover {
background-color: #e2c0d3;
}

.result-label {
width: 150px;
font-size: 16px;
font-weight: 400;
color: var(--text-color-subtle);
margin-right: 20px;
}

.result-value {
font-size: 20px;
font-weight: 500;
font-family: 'Montserrat', var(--font-futura), sans-serif;
flex-grow: 1;
}

.color-swatch {
width: 20px;
height: 20px;
border: 1px solid var(--text-color-subtle);
margin-left: 10px;
}

/* â˜… ä¿®æ­£: æ³¢å½¢ãƒ¢ãƒ‹ã‚¿ãƒ¼ã®UI */
.waveform-container {
    padding: 10px 0;
    border-bottom: 1px solid var(--line-subtle);
}
.waveform-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px dashed var(--line-subtle);
}
.waveform-header .hist-label {
    margin: 0; 
    padding: 0; 
    font-size: 16px; 
    text-align: left;
    color: var(--text-color-subtle);
}
.waveform-header div {
    font-size: 14px;
    display: flex;
    gap: 10px;
}
.waveform-header input[type="radio"] {
    display: none; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã‚’éš ã™ */
}
.waveform-header input[type="radio"] + label {
    cursor: pointer;
    padding: 4px 10px;
    border: 1px solid var(--line-subtle);
    border-radius: 4px;
    color: var(--text-color-primary);
    background-color: var(--main-card-bg);
    transition: background-color 0.2s, border-color 0.2s;
    font-family: var(--font-futura);
}
.waveform-header input[type="radio"]:hover + label {
    border-color: var(--accent-color);
}
.waveform-header input[type="radio"]:checked + label {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    color: #fff;
}

#waveformCanvas {
    width: 100%;
    height: 150px;
    background-color: var(--scope-bg-color);
}


/* --- ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—å°‚ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
#vectorscopeCard {
margin-top: 20px;
width: 100%;
background-color: var(--main-card-bg); /* å‘¨å›²ã®ã‚«ãƒ¼ãƒ‰ã¨æƒãˆã‚‹ */
padding: 20px;
display: flex;
flex-direction: column;
align-items: center;

border: 1px solid var(--border-color);
border-radius: var(--card-radius);
}

/* æ­£å††ã‚’ç¶­æŒã™ã‚‹ãŸã‚ã®ãƒ©ãƒƒãƒ‘ãƒ¼ */
#vectorscopeWrapper {
    width: 250px; 
    height: 250px;
    margin: 0 auto 10px auto;
}

#vectorscopeCanvas {
    width: 100%;
    height: 100%;
    display: block;
    background-color: var(--scope-bg-color); 
    border: none; 
    border-radius: 50%; 
    cursor: default;
}

.scope-data-display {
    text-align: center;
    width: 100%;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed var(--line-subtle);
    display: flex;
    justify-content: space-around;
    font-family: var(--font-futura);
}

.scope-data-item {
    font-size: 14px;
    line-height: 1.4;
}

.scope-data-label {
    font-weight: 400;
    color: var(--text-color-subtle);
    display: block;
    font-size: 12px;
}

.scope-data-value {
    font-weight: 600;
    color: var(--text-color-primary);
    display: block;
    font-size: 16px;
}
/* ------------------------------------- */

/* â˜… ä¿®æ­£: å‡¦ç†æ¸ˆã¿ç”»åƒã‚¨ãƒªã‚¢ (æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¨CSSãƒªã‚µã‚¤ã‚º) */
#processedImagesArea {
    margin-top: 40px;
    display: flex; /* Flexboxã§æ¨ªä¸¦ã³ã« */
    gap: 20px;
    background-color: var(--bg-color);
    padding: 0;
    overflow-x: auto; /* æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’å¯èƒ½ã« */
    white-space: nowrap; /* å­è¦ç´ ãŒæŠ˜ã‚Šè¿”ã•ãªã„ã‚ˆã†ã« */
    padding-bottom: 15px; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®ãŸã‚ã®ä½™ç™½ */
    width: 100%; /* è¦ªè¦ç´ ã®å¹…ã«åˆã‚ã›ã‚‹ */
    box-sizing: border-box;
}

.processed-image-card {
    flex: 0 0 auto; /* å¹…ã‚’å›ºå®šã—ã€ä¼¸ç¸®ã•ã›ãªã„ */
    width: 300px; /* ã‚«ãƒ¼ãƒ‰ã®åŸºæº–å¹… */
    background-color: var(--main-card-bg);
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;

    border: 1px solid var(--border-color);
    border-radius: var(--card-radius);
}

.processed-image-card canvas {
    width: 100%; /* è¦ªã‚«ãƒ¼ãƒ‰ã®å¹…(300px)ã«åˆã‚ã›ã‚‹ */
    height: 150px; /* å›ºå®šã®è¡¨ç¤ºé«˜ã•ã‚’è¨­å®š */
    display: block;
    border: none;
    margin-bottom: 10px;
    cursor: pointer;
    transition: border-color 0.2s ease;
    
    /* â˜… ä¿®æ­£: å†…éƒ¨è§£åƒåº¦ã‚’ç¶­æŒã—ã¤ã¤ã€è¦‹ãŸç›®ã‚’ç¸®å° */
    object-fit: contain; /* ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ã¤ã¤ã€æŒ‡å®šã—ãŸé ˜åŸŸå†…ã«åã¾ã‚‹ã‚ˆã†ã«ç¸®å° */
    image-rendering: pixelated; /* ã‚·ãƒ£ãƒ¼ãƒ—ãªç¸®å°è¡¨ç¤ºã« */
    background-color: #ddd; /* ç¸®å°è¡¨ç¤ºæ™‚ã®èƒŒæ™¯è‰² */
}

.processed-image-card canvas:hover {
border-color: var(--line-strong);
}

.processed-image-card p {
font-size: 14px;
color: var(--text-color-subtle);
margin: 0;
white-space: normal; /* ã‚«ãƒ¼ãƒ‰åã¯æŠ˜ã‚Šè¿”ã—ã¦OK */
}


/* ãƒ•ãƒƒã‚¿ãƒ¼ */
footer {
margin-top: 80px;
font-size: 12px;
color: var(--text-color-subtle);
font-family: var(--font-body);
}

/* ã‚¹ãƒã‚¤ãƒˆæƒ…å ±ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ */
#eyedropperInfo {
    position: fixed;
    background-color: rgba(30, 30, 30, 0.85);
    color: #fff;
    padding: 8px 12px;
    border-radius: 5px;
    font-size: 12px;
    z-index: 2000;
    pointer-events: none;
    display: none;
    font-family: var(--font-futura);
    border: 1px solid #fff;
    backdrop-filter: blur(5px);
}
#eyedropperInfo .info-line {
    display: flex;
    justify-content: space-between;
}
#eyedropperInfo .info-label {
    color: #aaa;
    margin-right: 10px;
    min-width: 30px;
}
#eyedropperInfo .info-value {
    color: #fff;
    font-weight: 600;
}


/* ã‚³ãƒ”ãƒ¼ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ— */
.copy-tooltip {
position: fixed;
background-color: #333;
color: #fff;
padding: 5px 10px;
border-radius: 3px;
font-size: 12px;
z-index: 1000;
pointer-events: none;
opacity: 0;
transition: opacity 0.3s ease;
}
.copy-tooltip.show {
opacity: 1;
}

/* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
@media (max-width: 768px) {
    body {
        padding: 20px 15px; 
        min-height: auto;
    }

    h2 {
        font-size: 28px; 
    }

    .sub-text {
        font-size: 13px;
        margin-bottom: 30px;
    }

    #initialDropArea {
        width: 100%; 
        height: 250px; 
    }

    #initialDropArea p {
        font-size: 20px;
        padding: 3px 10px;
    }

    #analysisContainer {
        grid-template-columns: 1fr; 
        gap: 30px; 
    }

    .left-panel {
        padding: 20px;
    }

    .right-panel {
        padding: 0;
    }
    
    #zebraControls {
        font-size: 12px;
        padding: 8px;
        flex-wrap: wrap; 
        gap: 5px;
    }
    #zebraControls input[type="number"] {
        width: 40px;
    }

    .hist-label {
        font-size: 18px;
    }
    
    .result-item {
        padding: 8px 0;
    }

    .result-label {
        width: 120px; 
        font-size: 15px;
    }

    .result-value {
        font-size: 18px;
    }
    
    .waveform-header div {
        font-size: 12px;
    }
    #waveformCanvas {
        height: 120px;
    }

    #vectorscopeCard {
        padding: 15px;
    }

    #vectorscopeWrapper {
        width: 200px; 
        height: 200px;
    }
    
    .scope-data-display {
        font-size: 12px;
    }
    
    .scope-data-value {
        font-size: 14px;
    }

    #processedImagesArea {
        gap: 15px;
        margin-top: 30px;
    }
    
    .processed-image-card {
        padding: 15px;
        width: 250px; /* ã‚¹ãƒãƒ›ã§ã®ã‚«ãƒ¼ãƒ‰å¹…ã‚’èª¿æ•´ */
    }
    .processed-image-card canvas {
        height: 120px; /* ã‚¹ãƒãƒ›ã§ã®è¡¨ç¤ºé«˜ã•ã‚’èª¿æ•´ */
    }
}
</style>
</head>
<body>

<h2>ç™½é»’æ¯”ï¼†ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—èªè­˜ãƒ„ãƒ¼ãƒ«</h2>
<p class="sub-text">ç”»åƒã®ç™½é»’ã®æ¯”ç‡ã¨è‰²åˆ†å¸ƒã‚’èªè­˜ã—ã¦ãã‚Œã‚‹ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚<br>ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã¨ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>

<div id="initialDropArea">
<input type="file" id="initialFileInput" accept="image/*">
<p>ç”»åƒã‚’ D&D ã§è¿½åŠ </p>
</div>

<div id="analysisContainer" style="display: none;">

<div class="left-panel">
    
    <canvas id="resultImagePreview"></canvas>
    
    <div id="imagePlaceholder">ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚</div>

    <div id="zebraControls" style="display: none;">
        <label for="zebraToggle">ã‚¼ãƒ–ãƒ©</label>
        <input type="checkbox" id="zebraToggle">
        
        <label for="zebraThresholdSlider" style="margin-left: 10px;">é–¾å€¤:</label>
        <input type="range" id="zebraThresholdSlider" value="90" min="0" max="100" step="1">
        <input type="number" id="zebraThresholdNumber" value="90" min="0" max="100" step="1">
        <span>%</span>
    </div>

    <p class="hist-label">ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ </p>
    <canvas id="histogramCanvas"></canvas>
</div>


<div class="right-panel">

    <div class="result-item" data-copy-target="blackRatio">
        <span class="result-label">é»’ã®å‰²åˆ:</span>
        <span class="result-value" id="blackRatioValue">--</span>
    </div>
    <div class="result-item" data-copy-target="whiteRatio">
        <span class="result-label">ç™½ã®å‰²åˆ:</span>
        <span class="result-value" id="whiteRatioValue">--</span>
    </div>
    <div class="result-item" data-copy-target="lightColor">
        <span class="result-label">æœ€ã‚‚æ˜ã‚‹ã„è‰²:</span>
        <span class="result-value" id="lightColorValue">#FFFFFF</span>
        <div class="color-swatch" id="lightColorSwatch"></div>
    </div>
    <div class="result-item" data-copy-target="darkColor">
        <span class="result-label">æœ€ã‚‚æš—ã„è‰²:</span>
        <span class="result-value" id="darkColorValue">#000000</span>
        <div class="color-swatch" id="darkColorSwatch"></div>
    </div>
    <div class="result-item" data-copy-target="contrastRatio">
        <span class="result-label">ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆæ¯”:</span>
        <span class="result-value" id="contrastRatioValue">--:1</span>
    </div>

    <div class="waveform-container">
        <div class="waveform-header">
            <span class="hist-label">æ³¢å½¢ãƒ¢ãƒ‹ã‚¿ãƒ¼</span>
            <div>
                <input type="radio" id="waveModeLuma" name="waveMode" value="Luma" checked>
                <label for="waveModeLuma">è¼åº¦</label>
                <input type="radio" id="waveModeRGB" name="waveMode" value="RGB">
                <label for="waveModeRGB">RGB</label>
            </div>
        </div>
        <canvas id="waveformCanvas"></canvas>
    </div>

    <div id="vectorscopeCard">
        <p class="hist-label" style="margin-top: 0; padding-top: 0; font-size: 16px;">ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ— (Cr/Cb)</p>
        <div id="vectorscopeWrapper">
            <canvas id="vectorscopeCanvas"></canvas>
        </div>
        <div class="scope-data-display">
            <div class="scope-data-item">
                <span class="scope-data-label">R-Y (Cr) Max</span>
                <span class="scope-data-value" id="crMaxValue">--</span>
            </div>
            <div class="scope-data-item">
                <span class="scope-data-label">B-Y (Cb) Max</span>
                <span class="scope-data-value" id="cbMaxValue">--</span>
            </div>
            <div class="scope-data-item">
                <span class="scope-data-label">Saturation Max</span>
                <span class="scope-data-value" id="satMaxValue">--</span>
            </div>
        </div>
    </div>

    <div id="processedImagesArea">
        <div class="processed-image-card">
            <canvas id="binaryCanvas" data-filename="binary_image.png"></canvas>
            <p>äºŒå€¤åŒ–ç”»åƒ</p>
        </div>
        <div class="processed-image-card">
            <canvas id="grayscaleCanvas" data-filename="grayscale_image.png"></canvas>
            <p>è¼åº¦ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«</p>
        </div>
        <div class="processed-image-card">
            <canvas id="saturationGrayscaleCanvas" data-filename="saturation_grayscale_image.png"></canvas>
            <p>å½©åº¦ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«</p>
        </div>
        <div class="processed-image-card">
            <canvas id="luminosityGrayscaleCanvas" data-filename="luminosity_grayscale_image.png"></canvas>
            <p>æ˜åº¦ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«</p>
        </div>
    </div>

</div>
</div>

<footer>
<p>Created by Sabiasagi</p>
</footer>

<div id="eyedropperInfo">
    <div class="info-line">
        <span class="info-label">POS:</span>
        <span class="info-value" id="spotPos">--</span>
    </div>
    <div class="info-line">
        <span class="info-label">HEX:</span>
        <span class="info-value" id="spotHex">--</span>
    </div>
    <div class="info-line">
        <span class="info-label">RGB:</span>
        <span class="info-value" id="spotRGB">--</span>
    </div>
    <div class="info-line">
        <span class="info-label">LUM:</span>
        <span class="info-value" id="spotLum">--</span>
    </div>
</div>

<div id="copyTooltip" class="copy-tooltip">ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼</div>

<script>
// --- 1. å¤‰æ•°å®šç¾©ã¨åˆæœŸè¨­å®š ---
const DOM = {
initialDropArea: document.getElementById('initialDropArea'),
initialFileInput: document.getElementById('initialFileInput'),
analysisContainer: document.getElementById('analysisContainer'),
resultImagePreview: document.getElementById('resultImagePreview'), 
imagePlaceholder: document.getElementById('imagePlaceholder'),
histogramCanvas: document.getElementById('histogramCanvas'),
binaryCanvas: document.getElementById('binaryCanvas'),
grayscaleCanvas: document.getElementById('grayscaleCanvas'),
// â˜… æ–°ã—ã„ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«Canvasã‚’è¿½åŠ 
saturationGrayscaleCanvas: document.getElementById('saturationGrayscaleCanvas'),
luminosityGrayscaleCanvas: document.getElementById('luminosityGrayscaleCanvas'),

vectorscopeCanvas: document.getElementById('vectorscopeCanvas'), 
copyTooltip: document.getElementById('copyTooltip'),
values: {
blackRatio: document.getElementById('blackRatioValue'),
whiteRatio: document.getElementById('whiteRatioValue'),
lightColor: document.getElementById('lightColorValue'),
darkColor: document.getElementById('darkColorValue'),
contrastRatio: document.getElementById('contrastRatioValue')
},
swatches: {
lightColor: document.getElementById('lightColorSwatch'),
darkColor: document.getElementById('darkColorSwatch')
},
scopeValues: {
    crMax: document.getElementById('crMaxValue'),
    cbMax: document.getElementById('cbMaxValue'),
    satMax: document.getElementById('satMaxValue')
},
// ã‚¼ãƒ–ãƒ©DOM
zebraControls: document.getElementById('zebraControls'),
zebraToggle: document.getElementById('zebraToggle'),
zebraThresholdSlider: document.getElementById('zebraThresholdSlider'),
zebraThresholdNumber: document.getElementById('zebraThresholdNumber'),
// ã‚¹ãƒã‚¤ãƒˆ
eyedropperInfo: document.getElementById('eyedropperInfo'),
spotPos: document.getElementById('spotPos'),
spotHex: document.getElementById('spotHex'),
spotRGB: document.getElementById('spotRGB'),
spotLum: document.getElementById('spotLum'),
// æ³¢å½¢
waveformCanvas: document.getElementById('waveformCanvas'),
waveModeLuma: document.getElementById('waveModeLuma'),
waveModeRGB: document.getElementById('waveModeRGB')
};

// ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let currentImage = null; // ç”»åƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
let currentImageData = null; // ãƒ•ãƒ«è§£åƒåº¦ã®ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ (ImageData)
let previewCtx = DOM.resultImagePreview.getContext('2d');

// --- 2. ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ç™»éŒ² ---
// ãƒ‰ãƒ­ãƒƒãƒ—ã‚¨ãƒªã‚¢
DOM.initialDropArea.addEventListener('click', () => DOM.initialFileInput.click());
DOM.initialFileInput.addEventListener('change', e => {
if (e.target.files.length > 0) handleFile(e.target.files[0]);
});
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
DOM.initialDropArea.addEventListener(eventName, preventDefaults, false);
});
DOM.initialDropArea.addEventListener('dragenter', () => DOM.initialDropArea.classList.add('highlight'), false);
DOM.initialDropArea.addEventListener('dragleave', () => DOM.initialDropArea.classList.remove('highlight'), false);
DOM.initialDropArea.addEventListener('drop', handleDrop, false);

function preventDefaults(e) {
e.preventDefault();
e.stopPropagation();
}

function handleDrop(e) {
const files = e.dataTransfer.files;
if (files.length > 0) {
DOM.initialDropArea.classList.remove('highlight');
handleFile(files[0]);
}
}

// ã‚³ãƒ”ãƒ¼æ©Ÿèƒ½
document.querySelectorAll('.result-item').forEach(item => {
item.addEventListener('click', copyTextToClipboard);
});

// ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½
[DOM.binaryCanvas, DOM.grayscaleCanvas, DOM.saturationGrayscaleCanvas, DOM.luminosityGrayscaleCanvas].forEach(canvas => {
canvas.addEventListener('click', () => downloadCanvasImage(canvas, canvas.dataset.filename));
});

// ã‚¼ãƒ–ãƒ©ï¼ˆã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨æ•°å€¤å…¥åŠ›ã®é€£å‹•ï¼‰
DOM.zebraToggle.addEventListener('change', onZebraChange);
DOM.zebraThresholdSlider.addEventListener('input', onZebraSliderChange);
DOM.zebraThresholdNumber.addEventListener('input', onZebraNumberChange);

function onZebraSliderChange() {
    DOM.zebraThresholdNumber.value = DOM.zebraThresholdSlider.value;
    onZebraChange();
}
function onZebraNumberChange() {
    // å…¥åŠ›å€¤ãŒç¯„å›²å¤–ã®å ´åˆã€ä¸¸ã‚ã‚‹
    let val = parseInt(DOM.zebraThresholdNumber.value, 10);
    if (isNaN(val)) val = 0;
    if (val < 0) val = 0;
    if (val > 100) val = 100;
    DOM.zebraThresholdNumber.value = val;
    DOM.zebraThresholdSlider.value = val;
    onZebraChange();
}

// ã‚¹ãƒã‚¤ãƒˆ
DOM.resultImagePreview.addEventListener('mousemove', handlePreviewMouseMove);
DOM.resultImagePreview.addEventListener('mouseleave', handlePreviewMouseLeave);
// æ³¢å½¢
DOM.waveModeLuma.addEventListener('change', onWaveModeChange);
DOM.waveModeRGB.addEventListener('change', onWaveModeChange);


// --- 3. ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ ---

function handleFile(file) {
if (!file.type.startsWith('image/')) return;

const reader = new FileReader();
reader.onload = (e) => {
const img = new Image();
img.onload = () => {
    currentImage = img; 

    // UIåˆ‡ã‚Šæ›¿ãˆ
    DOM.initialDropArea.style.display = 'none';
    DOM.imagePlaceholder.style.display = 'none';
    DOM.resultImagePreview.style.display = 'block';
    DOM.zebraControls.style.display = 'flex'; 

    DOM.analysisContainer.style.opacity = '0';
    DOM.analysisContainer.style.display = 'grid';
    setTimeout(() => { DOM.analysisContainer.style.opacity = '1'; }, 50);

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼Canvasã«ç”»åƒã‚’æç”»
    drawPreviewCanvas();
    
    // è§£æã‚’å®Ÿè¡Œ (ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ä¿å­˜)
    analyzeAndDisplayResults(img);
};
img.src = e.target.result;
};
reader.readAsDataURL(file);
}

// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼Canvasã«æç”»ã™ã‚‹é–¢æ•°
function drawPreviewCanvas() {
    if (!currentImage || !previewCtx) return;
    const canvas = DOM.resultImagePreview;
    
    // CSSã®å¹…ã«Canvasã®è§£åƒåº¦ã‚’åˆã‚ã›ã‚‹
    const aspectRatio = currentImage.height / currentImage.width;
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetWidth * aspectRatio;
    
    previewCtx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
}

function analyzeAndDisplayResults(img) {
// ãƒ•ãƒ«è§£åƒåº¦ã®ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ä¿å­˜
const tempCanvas = document.createElement('canvas');
const tempCtx = tempCanvas.getContext('2d');
tempCanvas.width = img.width;
tempCanvas.height = img.height;
tempCtx.drawImage(img, 0, 0);

currentImageData = tempCtx.getImageData(0, 0, img.width, img.height);
const data = currentImageData.data;

// --- ã“ã“ã‹ã‚‰æ—¢å­˜ã®è§£æãƒ­ã‚¸ãƒƒã‚¯ ---
const histogram = new Array(256).fill(0);
let minLum = 256, maxLum = -1;
let minColor = [0,0,0], maxColor = [255,255,255];
let maxCr = 0, maxCb = 0, maxSat = 0; 

for (let i = 0; i < data.length; i += 4) {
const r = data[i], g = data[i+1], b = data[i+2];
const rNorm = r / 255, gNorm = g / 255, bNorm = b / 255; 
const lum = Math.round(0.299*r + 0.587*g + 0.114*b); 
histogram[lum]++;

if (lum < minLum) { minLum = lum; minColor = [r,g,b]; }
if (lum > maxLum) { maxLum = lum; maxColor = [r,g,b]; }

// YCrCbã®è¨ˆç®—
const yNorm = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
const cbNorm = bNorm - yNorm; // B-Y
const crNorm = rNorm - yNorm; // R-Y
const satNorm = Math.sqrt(crNorm * crNorm + cbNorm * cbNorm); // å½©åº¦

maxCr = Math.max(maxCr, Math.abs(crNorm));
maxCb = Math.max(maxCb, Math.abs(cbNorm));
maxSat = Math.max(maxSat, satNorm);

}

const threshold = otsuThreshold(histogram, img.width * img.height);

let black = 0, white = 0;
for (let i = 0; i < 256; i++) {
if (i < threshold) black += histogram[i];
else white += histogram[i];
}

const totalPixels = black + white;
const blackRatio = (black / totalPixels * 100).toFixed(2);
const whiteRatio = (white / totalPixels * 100).toFixed(2);

const darkestHex = rgbToHex(...minColor);
const lightestHex = rgbToHex(...maxColor);
const contrast = getContrastRatio(lightestHex, darkestHex);

// UIã®æ›´æ–°
DOM.values.blackRatio.textContent = `${blackRatio}%`;
DOM.values.whiteRatio.textContent = `${whiteRatio}%`;
DOM.values.lightColor.textContent = lightestHex;
DOM.values.darkColor.textContent = darkestHex;
DOM.swatches.lightColor.style.backgroundColor = lightestHex;
DOM.swatches.darkColor.style.backgroundColor = darkestHex;
DOM.values.contrastRatio.textContent = `${contrast.toFixed(2)}:1`;

DOM.scopeValues.crMax.textContent = maxCr.toFixed(4);
DOM.scopeValues.cbMax.textContent = maxCb.toFixed(4);
DOM.scopeValues.satMax.textContent = maxSat.toFixed(4);

// æç”»
animateHistogram(DOM.histogramCanvas, histogram, threshold);
drawVectorscope(DOM.vectorscopeCanvas, data); 

// â˜… ä¿®æ­£: å…¨ã¦ã®ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æç”»
drawProcessedImage(DOM.binaryCanvas, img, threshold, 'binary');
drawProcessedImage(DOM.grayscaleCanvas, img, threshold, 'grayscale');
drawProcessedImage(DOM.saturationGrayscaleCanvas, img, threshold, 'saturation');
drawProcessedImage(DOM.luminosityGrayscaleCanvas, img, threshold, 'luminosity');


// â˜… æ–°æ©Ÿèƒ½: æ³¢å½¢ãƒ¢ãƒ‹ã‚¿ãƒ¼ã‚’åˆå›æç”»
drawWaveform();
// â˜… æ–°æ©Ÿèƒ½: ã‚¼ãƒ–ãƒ©ãŒã‚‚ã—ONãªã‚‰åˆå›æç”»
onZebraChange();
}

// â˜… ä¿®æ­£: å‡¦ç†æ¸ˆã¿ç”»åƒã®æç”» (ãƒ•ãƒ«è§£åƒåº¦ + æ–°ãƒ¢ãƒ¼ãƒ‰)
function drawProcessedImage(canvas, originalImg, threshold, mode) {
    // å…ƒç”»åƒã®è§£åƒåº¦ã§Canvasã‚’è¨­å®š
    canvas.width = originalImg.width;
    canvas.height = originalImg.height;

    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false; 
    ctx.drawImage(originalImg, 0, 0, originalImg.width, originalImg.height); 

    const imageData = ctx.getImageData(0, 0, originalImg.width, originalImg.height);
    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i+1], b = data[i+2];
        let color;

        if (mode === 'binary' || mode === 'grayscale') {
            const lum = Math.round(0.299*r + 0.587*g + 0.114*b); // è¼åº¦ (Luma)
            if (mode === 'binary') {
                color = lum < threshold ? 0 : 255;
            } else {
                color = lum;
            }
        } else {
            // HSL Calculation for Saturation and Luminosity (Lightness)
            const rN = r / 255, gN = g / 255, bN = b / 255;
            const max = Math.max(rN, gN, bN), min = Math.min(rN, gN, bN);
            let s, l = (max + min) / 2;

            if (max === min) {
                s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            }

            if (mode === 'saturation') {
                color = Math.round(s * 255);
            } else if (mode === 'luminosity') {
                color = Math.round(l * 255); // æ˜åº¦ (Lightness)
            }
        }
        data[i] = data[i+1] = data[i+2] = color;
    }
    // ãƒ•ãƒ«è§£åƒåº¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’Canvasã«æˆ»ã™
    ctx.putImageData(imageData, 0, 0);
}


// --- 4. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° ---

function otsuThreshold(hist, total) {
let sum = 0;
for (let i = 0; i < 256; i++) sum += i * hist[i];

let sumB = 0, wB = 0, wF = 0, varMax = 0, threshold = 0;

for (let i = 0; i < 256; i++) {
wB += hist[i];
if (wB === 0) continue;
wF = total - wB;
if (wF === 0) break;
sumB += i * hist[i];

const mB = sumB / wB;
const mF = (sum - sumB) / wF;
const varBetween = wB * wF * (mB - mF) ** 2;

if (varBetween > varMax) {
varMax = varBetween;
threshold = i;
}
}
return threshold;
}

// ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ (99ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«ã§è‡ªå‹•ã‚¹ã‚±ãƒ¼ãƒ«)
function animateHistogram(canvas, histogram, threshold) {
    const ctx = canvas.getContext('2d');
    
    const cssWidth = canvas.offsetWidth;
    const cssHeight = canvas.offsetHeight; 
    canvas.width = cssWidth; 
    canvas.height = cssHeight; 
    
    const w = canvas.width;
    const scaleHeight = 15; 
    const graphHeight = cssHeight - scaleHeight; 

    const sortedHist = [...histogram].filter(val => val > 0).sort((a, b) => a - b);
    let max;
    if (sortedHist.length > 0) {
        const percentileIndex = Math.floor(sortedHist.length * 0.99);
        max = sortedHist[percentileIndex];
    } else {
        max = 1; 
    }
    if (max < 10) { 
        max = Math.max(...histogram, 1);
    }
    
    const animationDuration = 800;
    const startTime = performance.now();

    function drawFrame(currentTime) {
        const elapsedTime = currentTime - startTime;
        const animationProgress = Math.min(1, elapsedTime / animationDuration);

        ctx.clearRect(0, 0, w, cssHeight); 

        ctx.beginPath();
        ctx.moveTo(0, graphHeight); 

        const currentDrawRange = w * animationProgress;

        for (let i = 0; i < currentDrawRange; i++) {
            const histIndex = Math.floor(i / w * 256); 
            const histValue = histogram[histIndex] || 0; 
            const barHeight = (histValue / max) * graphHeight; 
            const x = i;
            const y = graphHeight - barHeight; 

            if (i > 0) {
                const prevX = i - 1;
                const prevHistIndex = Math.floor(prevX / w * 256);
                const prevY = graphHeight - (histogram[prevHistIndex] / max) * graphHeight;
                ctx.bezierCurveTo(prevX + (x - prevX) * 0.5, prevY, x - (x - prevX) * 0.5, y, x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.lineTo(currentDrawRange, graphHeight); 
        
        ctx.fillStyle = 'var(--accent-color)';
        ctx.fill();
        ctx.strokeStyle = 'var(--accent-color)';
        ctx.lineWidth = 1;
        ctx.stroke();

        const grad = ctx.createLinearGradient(0, 0, w, 0); 
        grad.addColorStop(0, "#000000");
        grad.addColorStop(1, "#FFFFFF");
        ctx.fillStyle = grad;
        ctx.fillRect(0, graphHeight, w, scaleHeight); 

        if (animationProgress === 1) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; 
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const thresholdX = threshold / 256 * w; 
            ctx.moveTo(thresholdX, 0);
            ctx.lineTo(thresholdX, graphHeight + scaleHeight);
            ctx.stroke();
        }
        
        if (animationProgress < 1) {
            requestAnimationFrame(drawFrame);
        }
    }

    requestAnimationFrame(drawFrame);
}

// ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—
function drawVectorscope(canvas, pixelData) {
    const ctx = canvas.getContext('2d');
    const size = 250; 
    canvas.width = size;
    canvas.height = size;
    const center = size / 2;
    const radius = size / 2 - 15;
    const numPixels = pixelData.length / 4;
    const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--scope-grid-color').trim();
    ctx.fillStyle = 'var(--scope-bg-color)'; 
    ctx.fillRect(0, 0, size, size);
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(center, 0); ctx.lineTo(center, size);
    ctx.moveTo(0, center); ctx.lineTo(size, center);
    ctx.stroke();
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(center, center, radius * 0.66, 0, 2 * Math.PI); 
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(center, center, radius, 0, 2 * Math.PI);
    ctx.stroke();
    for (let i = 0; i < 360; i += 30) {
        const rad = i * (Math.PI / 180);
        const startR = radius * 1.05;
        const endR = radius * 1.15;
        const x1 = center + startR * Math.sin(rad);
        const y1 = center - startR * Math.cos(rad);
        const x2 = center + endR * Math.sin(rad);
        const y2 = center - endR * Math.cos(rad);
        ctx.lineWidth = i % 90 === 0 ? 1.5 : 1;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    const primaryColors = [
        { label: 'Y', angle: 0, color: '#FFFF00' },
        { label: 'M', angle: 30, color: '#FF00FF' },  
        { label: 'B', angle: 90, color: '#0000FF' },  
        { label: 'C', angle: 150, color: '#00FFFF' }, 
        { label: 'G', angle: 210, color: '#00FF00' }, 
        { label: 'R', angle: 330, color: '#FF0000' }  
    ];
    primaryColors.forEach(pc => {
        const rad = pc.angle * (Math.PI / 180);
        const markerRadius = radius * 0.8; 
        const x_marker = center + markerRadius * Math.sin(rad);
        const y_marker = center - markerRadius * Math.cos(rad);
        const labelRadius = radius * 1.3;
        const x_label = center + labelRadius * Math.sin(rad);
        const y_label = center - labelRadius * Math.cos(rad);
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 1;
        const boxSize = 15;
        ctx.beginPath();
        ctx.moveTo(x_marker - boxSize/2, y_marker - boxSize/2 + 5);
        ctx.lineTo(x_marker - boxSize/2, y_marker - boxSize/2);
        ctx.lineTo(x_marker - boxSize/2 + 5, y_marker - boxSize/2);
        ctx.moveTo(x_marker + boxSize/2 - 5, y_marker - boxSize/2);
        ctx.lineTo(x_marker + boxSize/2, y_marker - boxSize/2);
        ctx.lineTo(x_marker + boxSize/2, y_marker - boxSize/2 + 5);
        ctx.moveTo(x_marker + boxSize/2, y_marker + boxSize/2 - 5);
        ctx.lineTo(x_marker + boxSize/2, y_marker + boxSize/2);
        ctx.lineTo(x_marker + boxSize/2 - 5, y_marker + boxSize/2);
        ctx.moveTo(x_marker - boxSize/2 + 5, y_marker + boxSize/2);
        ctx.lineTo(x_marker - boxSize/2, y_marker + boxSize/2);
        ctx.lineTo(x_marker - boxSize/2, y_marker + boxSize/2 - 5);
        ctx.stroke();
        ctx.fillStyle = gridColor;
        ctx.font = '12px var(--font-futura)';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(pc.label, x_label, y_label);
    });
    const maxChrominance = 0.5;
    const plotRadius = radius; 
    ctx.globalCompositeOperation = 'lighter';
    const skip = Math.max(1, Math.floor(numPixels / 100000)); 
    for (let i = 0; i < pixelData.length; i += 4 * skip) {
        const r = pixelData[i] / 255;
        const g = pixelData[i+1] / 255;
        const b = pixelData[i+2] / 255;
        const yNorm = 0.299 * r + 0.587 * g + 0.114 * b;
        const cbNorm = b - yNorm; // Cb (Blue-Y) -> Xè»¸
        const crNorm = r - yNorm; // Cr (Red-Y) -> Yè»¸
        const plotCb = cbNorm * (plotRadius / maxChrominance);
        const plotCr = crNorm * (plotRadius / maxChrominance);
        const plotX = center + plotCb; 
        const plotY = center + plotCr;
        const dx = plotX - center;
        const dy = plotY - center;
        if (dx * dx + dy * dy <= plotRadius * plotRadius) {
            const hue = Math.atan2(plotCr, plotCb) * (180 / Math.PI) + 180;
            const sat = Math.sqrt(dx*dx + dy*dy) / plotRadius;
            ctx.fillStyle = `hsl(${hue}, 100%, ${50 + sat * 40}%)`; 
            ctx.fillRect(plotX, plotY, 1.5, 1.5); 
        }
    }
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(center - 1, center - 1, 3, 3);
}


function rgbToHex(r,g,b) {
return "#" + [r,g,b].map(x => x.toString(16).padStart(2, '0')).join('').toUpperCase();
}

function getLuminance(hex) {
const r = parseInt(hex.slice(1, 3), 16) / 255;
const g = parseInt(hex.slice(3, 5), 16) / 255;
const b = parseInt(hex.slice(5, 7), 16) / 255;
const toLinear = (c) => (c <= 0.03928) ? c / 12.92 : ((c + 0.055) / 1.055) ** 2.4;
const L = 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
return L;
}

function getContrastRatio(hex1, hex2) {
const L1 = getLuminance(hex1);
const L2 = getLuminance(hex2);
return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
}

// --- 5. ã‚³ãƒ”ãƒ¼/ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ ---

function copyTextToClipboard(e) {
const item = e.currentTarget;
const targetId = item.dataset.copyTarget;
let textToCopy = '';
switch(targetId) {
case 'blackRatio': textToCopy = DOM.values.blackRatio.textContent.replace('%', ''); break;
case 'whiteRatio': textToCopy = DOM.values.whiteRatio.textContent.replace('%', ''); break;
case 'lightColor': textToCopy = DOM.values.lightColor.textContent; break;
case 'darkColor': textToCopy = DOM.values.darkColor.textContent; break;
case 'contrastRatio': textToCopy = DOM.values.contrastRatio.textContent.replace(':1', ''); break;
}
if (textToCopy) {
navigator.clipboard.writeText(textToCopy).then(() => {
showTooltip(e.clientX, e.clientY);
}).catch(err => console.error('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ:', err));
}
}

let tooltipTimeout;
function showTooltip(x, y) {
DOM.copyTooltip.style.left = `${x + 10}px`;
DOM.copyTooltip.style.top = `${y - 20}px`;
DOM.copyTooltip.classList.add('show');
clearTimeout(tooltipTimeout);
tooltipTimeout = setTimeout(() => {
DOM.copyTooltip.classList.remove('show');
}, 1500);
}

function downloadCanvasImage(canvas, filename) {
const link = document.createElement('a');
link.download = filename || 'image.png';
canvas.toBlob((blob) => {
link.href = URL.createObjectURL(blob);
link.click();
URL.revokeObjectURL(link.href);
}, 'image/png');
}


// --- 6. â˜…â˜…â˜… æ–°æ©Ÿèƒ½ã®å®Ÿè£… â˜…â˜…â˜… ---

// â˜… ã‚¹ãƒã‚¤ãƒˆ: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸Šã‚’ãƒã‚¦ã‚¹ç§»å‹•
function handlePreviewMouseMove(e) {
    if (!currentImageData || !currentImage) return;

    const canvas = DOM.resultImagePreview;
    const rect = canvas.getBoundingClientRect();
    
    // Canvasä¸Šã®ãƒã‚¦ã‚¹åº§æ¨™
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // å…ƒç”»åƒã§ã®å¯¾å¿œã™ã‚‹åº§æ¨™ã‚’è¨ˆç®—
    const scaleX = currentImage.width / canvas.width;
    const scaleY = currentImage.height / canvas.height;
    
    const imgX = Math.floor(x * scaleX);
    const imgY = Math.floor(y * scaleY);

    if (imgX < 0 || imgX >= currentImage.width || imgY < 0 || imgY >= currentImage.height) {
        handlePreviewMouseLeave();
        return;
    }

    // ãƒ•ãƒ«è§£åƒåº¦ã®ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å€¤ã‚’å–å¾—
    const index = (imgY * currentImageData.width + imgX) * 4;
    const data = currentImageData.data;
    const r = data[index];
    const g = data[index+1];
    const b = data[index+2];
    
    const lum = Math.round(0.299*r + 0.587*g + 0.114*b);
    
    // æƒ…å ±ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æ›´æ–°
    DOM.spotPos.textContent = `${imgX}, ${imgY}`;
    DOM.spotHex.textContent = rgbToHex(r, g, b);
    DOM.spotRGB.textContent = `${r}, ${g}, ${b}`;
    DOM.spotLum.textContent = lum;
    
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ãƒã‚¦ã‚¹ä½ç½®ã«è¡¨ç¤º
    DOM.eyedropperInfo.style.left = `${e.clientX + 15}px`;
    DOM.eyedropperInfo.style.top = `${e.clientY}px`;
    DOM.eyedropperInfo.style.display = 'block';
}

// â˜… ã‚¹ãƒã‚¤ãƒˆ: ãƒã‚¦ã‚¹ãŒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‹ã‚‰å¤–ã‚ŒãŸ
function handlePreviewMouseLeave() {
    DOM.eyedropperInfo.style.display = 'none';
}

// â˜… ã‚¼ãƒ–ãƒ©: ãƒˆã‚°ãƒ«ã¾ãŸã¯é–¾å€¤ãŒå¤‰æ›´ã•ã‚ŒãŸ
function onZebraChange() {
    if (!currentImage) return;
    
    const thresholdValue = parseInt(DOM.zebraThresholdNumber.value, 10);
    
    if (DOM.zebraToggle.checked) {
        drawZebraPattern(thresholdValue);
    } else {
        drawPreviewCanvas(); // ã‚¼ãƒ–ãƒ©ã‚’æ¶ˆã—ã¦å…ƒã®ç”»åƒã‚’æç”»
    }
}

// â˜… ã‚¼ãƒ–ãƒ©: ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æç”»
function drawZebraPattern(thresholdValue) {
    if (!currentImageData || !previewCtx) return;

    // ã¾ãšå…ƒã®ç”»åƒã‚’ãƒ™ãƒ¼ã‚¹ã¨ã—ã¦æç”»
    drawPreviewCanvas(); 
    
    const canvas = DOM.resultImagePreview;
    const ctx = previewCtx;
    
    if (isNaN(thresholdValue)) return;
    
    const thresholdLuma = (thresholdValue / 100) * 255;
    
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼Canvasã®ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦æ“ä½œ
    const canvasImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const canvasData = canvasImageData.data;
    const canvasWidth = canvas.width;

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼Canvasã®ãƒ”ã‚¯ã‚»ãƒ«ã‚’ç›´æ¥èµ°æŸ»
    for (let i = 0; i < canvasData.length; i += 4) {
        const r = canvasData[i];
        const g = canvasData[i+1];
        const b = canvasData[i+2];
        
        // è¼åº¦ã‚’è¨ˆç®—
        const lum = 0.299*r + 0.587*g + 0.114*b;
        
        if (lum > thresholdLuma) {
            // é–¾å€¤ã‚’è¶…ãˆã¦ã„ãŸã‚‰ã€ã‚¼ãƒ–ãƒ©ï¼ˆç¸æ¨¡æ§˜ï¼‰ã«ã™ã‚‹
            const y = Math.floor((i / 4) / canvasWidth);
            const x = (i / 4) % canvasWidth;
            
            if ((x + y) % 8 < 4) { // ç¸æ¨¡æ§˜ã®ãƒ­ã‚¸ãƒƒã‚¯
                canvasData[i] = 255;   // R
                canvasData[i+1] = 0;   // G
                canvasData[i+2] = 0;   // B
                canvasData[i+3] = 200; // Alpha
            }
        }
    }
    // æ“ä½œã—ãŸãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’Canvasã«æˆ»ã™
    ctx.putImageData(canvasImageData, 0, 0);
}

// â˜… æ³¢å½¢: ãƒ¢ãƒ¼ãƒ‰ãŒå¤‰æ›´ã•ã‚ŒãŸ
function onWaveModeChange() {
    drawWaveform();
}

// â˜… ä¿®æ­£: æ³¢å½¢ãƒ¢ãƒ‹ã‚¿ãƒ¼ã‚’æç”» (è¼åº¦ä¿®æ­£ + æ­ªã¿ä¿®æ­£)
function drawWaveform() {
    if (!currentImage) return;

    const canvas = DOM.waveformCanvas;
    const ctx = canvas.getContext('2d');
    const mode = DOM.waveModeLuma.checked ? 'Luma' : 'RGB';
    
    const w = canvas.offsetWidth;
    const h = 150; 
    canvas.width = w;
    canvas.height = h;

    // ç”»åƒã‚’æ³¢å½¢è§£åƒåº¦ã«ç¸®å°ã—ã¦ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    const tempWaveCanvas = document.createElement('canvas');
    const tempWaveHeight = (currentImage.height / currentImage.width) * w;
    tempWaveCanvas.width = w;
    tempWaveCanvas.height = tempWaveHeight; 

    const tempWaveCtx = tempWaveCanvas.getContext('2d');
    
    tempWaveCtx.drawImage(currentImage, 0, 0, w, tempWaveHeight);
    const imageData = tempWaveCtx.getImageData(0, 0, w, tempWaveHeight);
    const data = imageData.data;

    // æç”»é–‹å§‹
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, w, h);

    const lumaBins = new Uint8Array(w * 256); // è¼åº¦
    const rBins = new Uint8Array(w * 256); // R
    const gBins = new Uint8Array(w * 256); // G
    const bBins = new Uint8Array(w * 256); // B

    // ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èµ°æŸ»ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆ
    for (let i = 0; i < data.length; i += 4) {
        const x = Math.floor((i / 4) % w); // Xåº§æ¨™ (0 to w-1)
        
        const r = data[i];
        const g = data[i+1];
        const b = data[i+2];
        const lum = Math.round(0.299*r + 0.587*g + 0.114*b);

        lumaBins[x * 256 + lum]++;
        rBins[x * 256 + r]++;
        gBins[x * 256 + g]++;
        bBins[x * 256 + b]++;
    }
    
    const accentColor = 'var(--accent-color)';
    
    if (mode === 'Luma') {
        // â˜… ä¿®æ­£: è¼åº¦ãƒ¢ãƒ¼ãƒ‰ã®æ„Ÿåº¦èª¿æ•´
        // ç¸®å°ç”»åƒã®é«˜ã•ã® 1/10 ç¨‹åº¦ã‚’æœ€å¤§è¼åº¦ã¨ã—ã¦ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
        const scalingMax = Math.max(1, Math.floor(tempWaveHeight / 10));
        drawWaveChannel(ctx, lumaBins, w, h, accentColor, scalingMax);
    } else { 
        // RGBãƒ‘ãƒ¬ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰
        ctx.globalCompositeOperation = 'lighter'; // è‰²ã‚’é‡ã­ã‚‹
        
        // â˜… ä¿®æ­£: RGBã®æ„Ÿåº¦èª¿æ•´
        const scalingMaxRGB = Math.max(1, Math.floor(tempWaveHeight / 20));
        drawWaveChannel(ctx, rBins, w, h, 'rgba(255, 0, 0, 0.7)', scalingMaxRGB);
        drawWaveChannel(ctx, gBins, w, h, 'rgba(0, 255, 0, 0.7)', scalingMaxRGB);
        drawWaveChannel(ctx, bBins, w, h, 'rgba(0, 0, 255, 0.7)', scalingMaxRGB);

        ctx.globalCompositeOperation = 'source-over'; // å…ƒã«æˆ»ã™
    }
}

// â˜… ä¿®æ­£: æ³¢å½¢æç”»ã®ã‚µãƒ–é–¢æ•° (ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ãƒ­ã‚¸ãƒƒã‚¯)
function drawWaveChannel(ctx, bins, w, h, color, scalingMax) {
    
    const hScale = h / 256; // è¼åº¦(0-255)ã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹ã®é«˜ã•(h)ã«ãƒãƒƒãƒ”ãƒ³ã‚°

    for (let x = 0; x < w; x++) {
        for (let l = 0; l < 256; l++) { // l = è¼åº¦/RGBå€¤
            const count = bins[x * 256 + l];
            if (count > 0) {
                // â˜… ä¿®æ­£: ãƒ”ã‚¯ã‚»ãƒ«æ•°ã«å¿œã˜ã¦ä¸é€æ˜åº¦ã‚’å¤‰ãˆã‚‹
                const opacity = Math.min(1, (count / scalingMax) * 0.7 + 0.3);
                
                if (color.includes('rgba')) { // RGBãƒ¢ãƒ¼ãƒ‰
                    ctx.globalAlpha = opacity;
                    ctx.fillStyle = color;
                } else { // è¼åº¦ãƒ¢ãƒ¼ãƒ‰
                    // accent-color ã®RGB (b95282) ã‚’ä½¿ã£ã¦rgbaã‚’ç”Ÿæˆ
                    ctx.fillStyle = `rgba(185, 82, 130, ${opacity})`;
                }
                
                // Yè»¸ã¯ä¸‹ãŒ0, ä¸ŠãŒ255ãªã®ã§åè»¢
                ctx.fillRect(x, h - (l * hScale) - 1, 1, 1); 
            }
        }
    }
    ctx.globalAlpha = 1.0; // ä¸é€æ˜åº¦ã‚’ãƒªã‚»ãƒƒãƒˆ
}

</script>
</body>
</html>
