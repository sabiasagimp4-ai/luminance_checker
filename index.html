<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ç™½é»’æ¯”ï¼†ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—èªè­˜ãƒ„ãƒ¼ãƒ«</title>

<script>
// Typekit (ãƒ•ã‚©ãƒ³ãƒˆ) ã®èª­ã¿è¾¼ã¿
  (function(d) {
    var config = {
      kitId: 'ydf1tls',
      scriptTimeout: 3000,
      async: true
    },
    h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
  })(document);
</script>
<style>
/* ğŸ¨ EIZOé¢¨ãƒŸãƒ‹ãƒãƒ«UI - ã“ã“ã‚’ç·¨é›†ã™ã‚Œã°å…¨ä½“ã®è‰²ã¨ãƒ•ã‚©ãƒ³ãƒˆãŒå¤‰ã‚ã‚Šã¾ã™ï¼ */
:root {
/* --- ğŸ¨ ã‚«ãƒ©ãƒ¼è¨­å®š --- */
--bg-color: #dbdbd7; 	 /* å…¨ä½“ã®èƒŒæ™¯è‰² (æ·¡ã„ã‚°ãƒ¬ãƒ¼) */
--main-card-bg: #dbdbd7; 	 /* ã‚«ãƒ¼ãƒ‰ã®èƒŒæ™¯è‰² (èƒŒæ™¯ã¨åŒã˜) */
--text-color-primary: #111111; /* ãƒ¡ã‚¤ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®è‰² (é»’) */
--text-color-subtle: #111111; 	/* ã‚µãƒ–ãƒ†ã‚­ã‚¹ãƒˆã®è‰² (ã‚°ãƒ¬ãƒ¼) */
--accent-color: #b95282; 	 /* å¼·èª¿è‰² (ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚„ãƒ›ãƒãƒ¼) */
--scope-grid-color: #a77d54; /* ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®ã‚°ãƒªãƒƒãƒ‰è‰² (ã‚´ãƒ¼ãƒ«ãƒ‰ç³») */
--scope-bg-color: #000000; /* ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®èƒŒæ™¯è‰² (é»’) */

/* --- ğŸ“ ç½«ç·šãƒ»ãƒ‡ã‚¶ã‚¤ãƒ³è¨­å®š --- */
--border-color: #111111; 	 /* ç¸å–ã‚Šã®è‰² (é»’) */
--card-radius: 8px; 	 	/* ã‚«ãƒ¼ãƒ‰ã®è§’ä¸¸ã‚µã‚¤ã‚º */
--line-subtle: #111111; 	 	/* ç´°ã„ç·šã®è‰² */
--line-strong: #111111; 	 	/* å¼·èª¿ç·šã®è‰² */
--threshold-color: #FFFFFF; 	/* é–¾å€¤ã®è‰² */

/* --- ğŸ–‹ï¸ ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š --- */
--font-heading: 'futura-100-book', "dnp-shuei-gothic-gin-std", sans-serif;
--font-body: 'dnp-shuei-gothic-gin-std', 'futura-100-book', sans-serif;
--font-futura: 'futura-100-book', sans-serif; /* ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®è¨ˆæ¸¬å€¤ç”¨ */
}

body {
font-family: var(--font-body);
text-align: center;
background: var(--bg-color);
margin: 0;
padding: 60px 40px;
color: var(--text-color-primary);
min-height: 100vh;
box-sizing: border-box;
display: flex;
flex-direction: column;
align-items: center;
font-weight: 400; 
}

h2 {
font-size: 36px;
font-weight: 500; 
color: var(--text-color-primary);
margin-bottom: 5px;
font-family: var(--font-heading);
letter-spacing: 0.05em;
}

.sub-text {
color: var(--text-color-subtle);
font-size: 14px;
font-family: var(--font-body);
line-height: 1.7;
margin-bottom: 50px;
}

/* --- ãƒ‰ãƒ­ãƒƒãƒ—é ˜åŸŸ (åˆæœŸçŠ¶æ…‹) --- */
#initialDropArea {
position: relative;
width: 800px;
height: 450px;
background-color: var(--main-card-bg);
display: flex;
justify-content: center;
align-items: center;
margin: 0 auto;
cursor: pointer;
transition: background-color 0.3s ease, border-color 0.3s ease;

border: 1px solid var(--border-color);
border-radius: var(--card-radius);
}

#initialDropArea:hover, #initialDropArea.highlight {
background-color: #be7792; 
border-color: var(--accent-color); 
}

#initialDropArea p {
color: var(--text-color-primary);
font-size: 24px;
font-weight: 500;
font-family: var(--font-body);
background-color: transparent;
padding: 5px 15px;
border: 1px solid var(--text-color-primary);
line-height: 1;
}

#initialFileInput {
display: none;
}

/* --- è§£æçµæœã‚³ãƒ³ãƒ†ãƒŠ --- */
@keyframes fadeIn {
from { opacity: 0; transform: translateY(10px); }
to { opacity: 1; transform: translateY(0); }
}

#analysisContainer {
opacity: 0;
animation: fadeIn 0.8s ease-out forwards;
animation-delay: 0.1s;
width: 100%;
max-width: 1200px;
margin-top: 40px;
display: grid;
grid-template-columns: 1fr 1fr;
gap: 40px;
align-items: start;
}

/* å·¦å´ã®ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¨ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®ãƒ‘ãƒãƒ« */
.left-panel {
display: flex;
flex-direction: column;
background-color: var(--main-card-bg);
padding: 30px;
color: var(--text-color-primary);
text-align: left;

border: 1px solid var(--border-color);
border-radius: var(--card-radius);
}

#imagePlaceholder {
width: 100%;
aspect-ratio: 16 / 9;
background-color: #222222;
display: flex;
justify-content: center;
align-items: center;
font-size: 24px;
font-weight: 500;
color: var(--text-color-subtle);
margin-bottom: 20px;
}

#resultImagePreview {
width: 100%;
height: auto;
display: none;
margin-bottom: 20px;
border: none;
}

.hist-label {
font-size: 20px;
font-weight: 500;
margin-top: 30px;
margin-bottom: 15px;
padding-top: 15px;
text-align: center;
font-family: var(--font-heading);
}

#histogramCanvas {
width: 100%;
height: 120px;
display: block;
background-color: var(--main-card-bg);
}

/* å³å´ã®è§£æçµæœã¨ã‚³ãƒ”ãƒ¼ãƒœã‚¿ãƒ³ã®ãƒ‘ãƒãƒ« */
.right-panel {
display: flex;
flex-direction: column;
background-color: var(--bg-color); 
padding: 0;
color: var(--text-color-primary);
text-align: left;
}

.result-item {
display: flex;
align-items: center;
padding: 10px 0;
border-bottom: 1px solid var(--line-subtle);
cursor: pointer;
transition: background-color 0.2s ease;
}

.result-item:hover {
background-color: #e2c0d3;
}

.result-label {
width: 150px;
font-size: 16px;
font-weight: 400;
color: var(--text-color-subtle);
margin-right: 20px;
}

.result-value {
font-size: 20px;
font-weight: 500;
font-family: 'Montserrat', var(--font-futura), sans-serif;
flex-grow: 1;
}

.color-swatch {
width: 20px;
height: 20px;
border: 1px solid var(--text-color-subtle);
margin-left: 10px;
}

/* --- ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—å°‚ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
#vectorscopeCard {
margin-top: 20px;
width: 100%;
background-color: var(--main-card-bg); /* å‘¨å›²ã®ã‚«ãƒ¼ãƒ‰ã¨æƒãˆã‚‹ */
padding: 20px;
display: flex;
flex-direction: column;
align-items: center;

border: 1px solid var(--border-color);
border-radius: var(--card-radius);
}

/* æ­£å††ã‚’ç¶­æŒã™ã‚‹ãŸã‚ã®ãƒ©ãƒƒãƒ‘ãƒ¼ */
#vectorscopeWrapper {
    width: 250px; 
    height: 250px;
    margin: 0 auto 10px auto;
}

#vectorscopeCanvas {
    /* ãƒ©ãƒƒãƒ‘ãƒ¼ã«åˆã‚ã›ã¦100%ã«ã—ã€æ­£æ–¹å½¢ã®ãƒ©ãƒƒãƒ‘ãƒ¼å†…ã§æ­£å††ã«æç”»ã™ã‚‹ */
    width: 100%;
    height: 100%;
    display: block;
    background-color: var(--scope-bg-color); 
    border: none; /* å¤–å´ã®æ ã¯ä¸è¦ */
    border-radius: 50%; /* æ­£å†† */
    cursor: default;
}

.scope-data-display {
    text-align: center;
    width: 100%;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed var(--line-subtle);
    display: flex;
    justify-content: space-around;
    font-family: var(--font-futura);
}

.scope-data-item {
    font-size: 14px;
    line-height: 1.4;
}

.scope-data-label {
    font-weight: 400;
    color: var(--text-color-subtle);
    display: block;
    font-size: 12px;
}

.scope-data-value {
    font-weight: 600;
    color: var(--text-color-primary);
    display: block;
    font-size: 16px;
}
/* ------------------------------------- */

/* å³ä¸‹ã®äºŒå€¤åŒ–/ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ */
#processedImagesArea {
margin-top: 40px;
display: grid;
grid-template-columns: 1fr 1fr;
gap: 20px;
background-color: var(--bg-color);
padding: 0;
}

.processed-image-card {
background-color: var(--main-card-bg);
padding: 20px;
display: flex;
flex-direction: column;
align-items: center;

border: 1px solid var(--border-color);
border-radius: var(--card-radius);
}

.processed-image-card canvas {
width: 100%;
height: auto;
max-height: 200px;
display: block;
border: none;
margin-bottom: 10px;
cursor: pointer;
transition: border-color 0.2s ease;
}

.processed-image-card canvas:hover {
border-color: var(--line-strong);
}

.processed-image-card p {
font-size: 14px;
color: var(--text-color-subtle);
margin: 0;
}


/* ãƒ•ãƒƒã‚¿ãƒ¼ */
footer {
margin-top: 80px;
font-size: 12px;
color: var(--text-color-subtle);
font-family: var(--font-body);
}

/* ã‚³ãƒ”ãƒ¼ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ— */
.copy-tooltip {
position: fixed;
background-color: #333;
color: #fff;
padding: 5px 10px;
border-radius: 3px;
font-size: 12px;
z-index: 1000;
pointer-events: none;
opacity: 0;
transition: opacity 0.3s ease;
}
.copy-tooltip.show {
opacity: 1;
}
</style>
</head>
<body>

<h2>ç™½é»’æ¯”ï¼†ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—èªè­˜ãƒ„ãƒ¼ãƒ«</h2>
<p class="sub-text">ç”»åƒã®ç™½é»’ã®æ¯”ç‡ã¨è‰²åˆ†å¸ƒã‚’èªè­˜ã—ã¦ãã‚Œã‚‹ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚<br>ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã¨ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>

<div id="initialDropArea">
<input type="file" id="initialFileInput" accept="image/*">
<p>ç”»åƒã‚’ D&D ã§è¿½åŠ </p>
</div>

<div id="analysisContainer" style="display: none;">

<div class="left-panel">
<img id="resultImagePreview" style="max-width: 100%; height: auto; margin-bottom: 20px;" alt="è§£æå¯¾è±¡ç”»åƒ">
<div id="imagePlaceholder">ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚</div>

<p class="hist-label">ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ </p>
<canvas id="histogramCanvas"></canvas>
</div>


<div class="right-panel">
<div class="result-item" data-copy-target="blackRatio">
<span class="result-label">é»’ã®å‰²åˆ:</span>
<span class="result-value" id="blackRatioValue">--</span>
</div>
<div class="result-item" data-copy-target="whiteRatio">
<span class="result-label">ç™½ã®å‰²åˆ:</span>
<span class="result-value" id="whiteRatioValue">--</span>
</div>
<div class="result-item" data-copy-target="lightColor">
<span class="result-label">æœ€ã‚‚æ˜ã‚‹ã„è‰²:</span>
<span class="result-value" id="lightColorValue">#FFFFFF</span>
<div class="color-swatch" id="lightColorSwatch"></div>
</div>
<div class="result-item" data-copy-target="darkColor">
<span class="result-label">æœ€ã‚‚æš—ã„è‰²:</span>
<span class="result-value" id="darkColorValue">#000000</span>
<div class="color-swatch" id="darkColorSwatch"></div>
</div>
<div class="result-item" data-copy-target="contrastRatio">
<span class="result-label">ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆæ¯”:</span>
<span class="result-value" id="contrastRatioValue">--:1</span>
</div>

<!-- â˜… ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã‚¨ãƒªã‚¢ (ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´ã«ã‚ˆã‚Šç§»å‹•) -->
<div id="vectorscopeCard">
    <p class="hist-label" style="margin-top: 0; padding-top: 0; font-size: 16px;">ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ— (Cr/Cb)</p>
    <div id="vectorscopeWrapper">
        <canvas id="vectorscopeCanvas"></canvas>
    </div>
    <div class="scope-data-display">
        <div class="scope-data-item">
            <span class="scope-data-label">R-Y (Cr) Max</span>
            <span class="scope-data-value" id="crMaxValue">--</span>
        </div>
        <div class="scope-data-item">
            <span class="scope-data-label">B-Y (Cb) Max</span>
            <span class="scope-data-value" id="cbMaxValue">--</span>
        </div>
        <div class="scope-data-item">
            <span class="scope-data-label">Saturation Max</span>
            <span class="scope-data-value" id="satMaxValue">--</span>
        </div>
    </div>
</div>
<!-- â˜… ----------------------------- -->


<div id="processedImagesArea">
<div class="processed-image-card">
<canvas id="binaryCanvas" data-filename="binary_image.png"></canvas>
<p>äºŒå€¤åŒ–ç”»åƒ</p>
</div>
<div class="processed-image-card">
<canvas id="grayscaleCanvas" data-filename="grayscale_image.png"></canvas>
<p>ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ç”»åƒ</p>
</div>
</div>

</div>
</div>

<footer>
<p>Created by Sabiasagi</p>
</footer>

<div id="copyTooltip" class="copy-tooltip">ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼</div>

<script>
// --- 1. å¤‰æ•°å®šç¾©ã¨åˆæœŸè¨­å®š ---
const DOM = {
initialDropArea: document.getElementById('initialDropArea'),
initialFileInput: document.getElementById('initialFileInput'),
analysisContainer: document.getElementById('analysisContainer'),
resultImagePreview: document.getElementById('resultImagePreview'),
imagePlaceholder: document.getElementById('imagePlaceholder'),
histogramCanvas: document.getElementById('histogramCanvas'),
binaryCanvas: document.getElementById('binaryCanvas'),
grayscaleCanvas: document.getElementById('grayscaleCanvas'),
vectorscopeCanvas: document.getElementById('vectorscopeCanvas'), 
copyTooltip: document.getElementById('copyTooltip'),
values: {
blackRatio: document.getElementById('blackRatioValue'),
whiteRatio: document.getElementById('whiteRatioValue'),
lightColor: document.getElementById('lightColorValue'),
darkColor: document.getElementById('darkColorValue'),
contrastRatio: document.getElementById('contrastRatioValue')
},
swatches: {
lightColor: document.getElementById('lightColorSwatch'),
darkColor: document.getElementById('darkColorSwatch')
},
scopeValues: { // â˜… æ–°è¦è¿½åŠ : ã‚¹ã‚³ãƒ¼ãƒ—è¨ˆæ¸¬å€¤
    crMax: document.getElementById('crMaxValue'),
    cbMax: document.getElementById('cbMaxValue'),
    satMax: document.getElementById('satMaxValue')
}
};

let currentImage = null; // ç”»åƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿æŒã—ã¦å†åˆ©ç”¨

// --- 2. ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ç™»éŒ² ---
// ãƒ‰ãƒ­ãƒƒãƒ—ã‚¨ãƒªã‚¢ã‚¯ãƒªãƒƒã‚¯
DOM.initialDropArea.addEventListener('click', () => DOM.initialFileInput.click());

// ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠæ™‚
DOM.initialFileInput.addEventListener('change', e => {
if (e.target.files.length > 0) handleFile(e.target.files[0]);
});

// ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†ã®çµ±åˆ
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
DOM.initialDropArea.addEventListener(eventName, preventDefaults, false);
});
DOM.initialDropArea.addEventListener('dragenter', () => DOM.initialDropArea.classList.add('highlight'), false);
DOM.initialDropArea.addEventListener('dragleave', () => DOM.initialDropArea.classList.remove('highlight'), false);
DOM.initialDropArea.addEventListener('drop', handleDrop, false);

function preventDefaults(e) {
e.preventDefault();
e.stopPropagation();
}

function handleDrop(e) {
const files = e.dataTransfer.files;
if (files.length > 0) {
DOM.initialDropArea.classList.remove('highlight');
handleFile(files[0]);
}
}

// ã‚³ãƒ”ãƒ¼æ©Ÿèƒ½ã®ç™»éŒ²
document.querySelectorAll('.result-item').forEach(item => {
item.addEventListener('click', copyTextToClipboard);
});

// ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ã®ç™»éŒ²
[DOM.binaryCanvas, DOM.grayscaleCanvas].forEach(canvas => {
canvas.addEventListener('click', () => downloadCanvasImage(canvas, canvas.dataset.filename));
});

// --- 3. ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ ---

function handleFile(file) {
if (!file.type.startsWith('image/')) return;

const reader = new FileReader();
reader.onload = (e) => {
const img = new Image();
img.onload = () => {
currentImage = img; // ç”»åƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿å­˜

// UIåˆ‡ã‚Šæ›¿ãˆã¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
DOM.initialDropArea.style.display = 'none';
DOM.resultImagePreview.src = img.src;
DOM.resultImagePreview.style.display = 'block';
DOM.imagePlaceholder.style.display = 'none';

DOM.analysisContainer.style.opacity = '0';
DOM.analysisContainer.style.display = 'grid';
setTimeout(() => { DOM.analysisContainer.style.opacity = '1'; }, 50);

analyzeAndDisplayResults(img);
};
img.src = e.target.result;
};
reader.readAsDataURL(file);
}

function analyzeAndDisplayResults(img) {
const tempCanvas = document.createElement('canvas');
const tempCtx = tempCanvas.getContext('2d');
tempCanvas.width = img.width;
tempCanvas.height = img.height;
tempCtx.drawImage(img, 0, 0);

const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
const data = imageData.data;
const histogram = new Array(256).fill(0);
let minLum = 256, maxLum = -1;
let minColor = [0,0,0], maxColor = [255,255,255];
let maxCr = 0, maxCb = 0, maxSat = 0; // â˜… æ–°è¦è¿½åŠ : è‰²åº¦è¨ˆæ¸¬å€¤

for (let i = 0; i < data.length; i += 4) {
const r = data[i], g = data[i+1], b = data[i+2];
const rNorm = r / 255, gNorm = g / 255, bNorm = b / 255; // 0-1ã«æ­£è¦åŒ–
const lum = Math.round(0.299*r + 0.587*g + 0.114*b); // è¼åº¦ (0-255)
histogram[lum]++;

if (lum < minLum) { minLum = lum; minColor = [r,g,b]; }
if (lum > maxLum) { maxLum = lum; maxColor = [r,g,b]; }

// YCrCbã®è¨ˆç®—
const yNorm = 0.299 * rNorm + 0.587 * gNorm + 0.114 * bNorm;
const cbNorm = bNorm - yNorm; // B-Y
const crNorm = rNorm - yNorm; // R-Y
const satNorm = Math.sqrt(crNorm * crNorm + cbNorm * cbNorm); // å½©åº¦

maxCr = Math.max(maxCr, Math.abs(crNorm));
maxCb = Math.max(maxCb, Math.abs(cbNorm));
maxSat = Math.max(maxSat, satNorm);

}

const threshold = otsuThreshold(histogram, img.width * img.height);

let black = 0, white = 0;
for (let i = 0; i < 256; i++) {
if (i < threshold) black += histogram[i];
else white += histogram[i];
}

const totalPixels = black + white;
const blackRatio = (black / totalPixels * 100).toFixed(2);
const whiteRatio = (white / totalPixels * 100).toFixed(2);

const darkestHex = rgbToHex(...minColor);
const lightestHex = rgbToHex(...maxColor);
const contrast = getContrastRatio(lightestHex, darkestHex);

// UIã®æ›´æ–°
DOM.values.blackRatio.textContent = `${blackRatio}%`;
DOM.values.whiteRatio.textContent = `${whiteRatio}%`;
DOM.values.lightColor.textContent = lightestHex;
DOM.values.darkColor.textContent = darkestHex;
DOM.swatches.lightColor.style.backgroundColor = lightestHex;
DOM.swatches.darkColor.style.backgroundColor = darkestHex;
DOM.values.contrastRatio.textContent = `${contrast.toFixed(2)}:1`;

// â˜… ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—å€¤ã®æ›´æ–°
DOM.scopeValues.crMax.textContent = maxCr.toFixed(4);
DOM.scopeValues.cbMax.textContent = maxCb.toFixed(4);
DOM.scopeValues.satMax.textContent = maxSat.toFixed(4);

// æç”»
animateHistogram(DOM.histogramCanvas, histogram, threshold);
drawProcessedImage(DOM.binaryCanvas, img, threshold, 'binary');
drawProcessedImage(DOM.grayscaleCanvas, img, threshold, 'grayscale');
drawVectorscope(DOM.vectorscopeCanvas, data, maxCr, maxCb, maxSat); 
}

// å‡¦ç†æ¸ˆã¿ç”»åƒã®æç”»ã‚’æ±ç”¨åŒ–/çµ±åˆ
function drawProcessedImage(canvas, originalImg, threshold, mode) {
// Canvasã®è¡¨ç¤ºã‚µã‚¤ã‚ºã‚’å–å¾—ã—ã¦ã€æç”»è§£åƒåº¦ã‚’åˆã‚ã›ã‚‹
const cssWidth = canvas.offsetWidth;
const cssHeight = canvas.offsetHeight; 
canvas.width = cssWidth;
canvas.height = cssHeight;

const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = true; 
ctx.drawImage(originalImg, 0, 0, cssWidth, cssHeight); // Canvasã®ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦æç”»

const imageData = ctx.getImageData(0, 0, cssWidth, cssHeight);
const data = imageData.data;

for (let i = 0; i < data.length; i += 4) {
const r = data[i], g = data[i+1], b = data[i+2];
const lum = Math.round(0.299*r + 0.587*g + 0.114*b);
let color;

if (mode === 'binary') {
color = lum < threshold ? 0 : 255;
} else { // grayscale
color = lum;
}
data[i] = data[i+1] = data[i+2] = color;
}
ctx.putImageData(imageData, 0, 0);
}


// --- 4. ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° ---

function otsuThreshold(hist, total) {
let sum = 0;
for (let i = 0; i < 256; i++) sum += i * hist[i];

let sumB = 0, wB = 0, wF = 0, varMax = 0, threshold = 0;

for (let i = 0; i < 256; i++) {
wB += hist[i];
if (wB === 0) continue;
wF = total - wB;
if (wF === 0) break;
sumB += i * hist[i];

const mB = sumB / wB;
const mF = (sum - sumB) / wF;
const varBetween = wB * wF * (mB - mF) ** 2;

if (varBetween > varMax) {
varMax = varBetween;
threshold = i;
}
}
return threshold;
}

// ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ (æ»‘ã‚‰ã‹ãªç·šã‚°ãƒ©ãƒ• - è‰²ã¨é–¾å€¤ã‚’å¤‰æ›´)
function animateHistogram(canvas, histogram, threshold) {
    const ctx = canvas.getContext('2d');
    
    // CSSã§è¨­å®šã•ã‚ŒãŸè¡¨ç¤ºã‚µã‚¤ã‚ºã‚’å–å¾—
    const cssWidth = canvas.offsetWidth;
    const cssHeight = canvas.offsetHeight; // 120px
    
    // Canvasã®æç”»è§£åƒåº¦ã‚’CSSã®è¡¨ç¤ºã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹
    canvas.width = cssWidth; 
    canvas.height = cssHeight; // 120px
    
    const w = canvas.width;
    const scaleHeight = 15; // è¼åº¦ã‚¹ã‚±ãƒ¼ãƒ«ã®é«˜ã•
    const graphHeight = cssHeight - scaleHeight; // ã‚°ãƒ©ãƒ•æœ¬ä½“ã®é«˜ã• (105px)
    const max = Math.max(...histogram);
    
    const animationDuration = 800;
    const startTime = performance.now();

    function drawFrame(currentTime) {
        const elapsedTime = currentTime - startTime;
        const animationProgress = Math.min(1, elapsedTime / animationDuration);

        ctx.clearRect(0, 0, w, cssHeight); // å…¨ä½“ã‚’ã‚¯ãƒªã‚¢

        // 1. ã‚°ãƒ©ãƒ•æç”» (å¼·èª¿è‰²)
        ctx.beginPath();
        ctx.moveTo(0, graphHeight); // ã‚°ãƒ©ãƒ•ã®åº• (105px) ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ

        const currentDrawRange = w * animationProgress;

        for (let i = 0; i < currentDrawRange; i++) {
            const histIndex = Math.floor(i / w * 256); 
            const histValue = histogram[histIndex] || 0; 
            const barHeight = (histValue / max) * graphHeight;
            const x = i;
            const y = graphHeight - barHeight; // graphHeight (105)ã‚’åŸºæº–ã«ä¸Šã¸

            // æ»‘ã‚‰ã‹ãªãƒ™ã‚¸ã‚§æ›²ç·š
            if (i > 0) {
                const prevX = i - 1;
                const prevHistIndex = Math.floor(prevX / w * 256);
                const prevY = graphHeight - (histogram[prevHistIndex] / max) * graphHeight;
                ctx.bezierCurveTo(prevX + (x - prevX) * 0.5, prevY, x - (x - prevX) * 0.5, y, x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.lineTo(currentDrawRange, graphHeight); // åº•ã«æˆ»ã‚‹
        
        ctx.fillStyle = 'var(--accent-color)';
        ctx.fill();
        ctx.strokeStyle = 'var(--accent-color)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // 2. è¼åº¦ã‚¹ã‚±ãƒ¼ãƒ« (ä¸‹éƒ¨)
        const grad = ctx.createLinearGradient(0, 0, w, 0); // æ¨ªæ–¹å‘ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        grad.addColorStop(0, "#000000");
        grad.addColorStop(1, "#FFFFFF");
        ctx.fillStyle = grad;
        ctx.fillRect(0, graphHeight, w, scaleHeight); // 105pxã‹ã‚‰15pxã®é«˜ã•ã§æç”»

        // 3. é–¾å€¤ã®ç·š (ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æœ€å¾Œã«æç”»)
        if (animationProgress === 1) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; 
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const thresholdX = threshold / 256 * w; 
            ctx.moveTo(thresholdX, 0);
            ctx.lineTo(thresholdX, graphHeight + scaleHeight); // Canvaså…¨ä½“ã‚’ç¸¦æ–­
            ctx.stroke();
        }
        
        if (animationProgress < 1) {
            requestAnimationFrame(drawFrame);
        }
    }

    requestAnimationFrame(drawFrame);
}

/**
 * ãƒ™ã‚¯ãƒˆãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æç”»ã™ã‚‹
 * YCrCbã®è‰²åº¦åº§æ¨™ç³»ã«åŸºã¥ã„ã¦ç”»åƒã®è‰²åˆ†å¸ƒã‚’ãƒ—ãƒ­ãƒƒãƒˆã™ã‚‹
 * @param {HTMLCanvasElement} canvas - æç”»å¯¾è±¡ã®ã‚­ãƒ£ãƒ³ãƒã‚¹è¦ç´ 
 * @param {Uint8ClampedArray} pixelData - ç”»åƒã®ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ (R, G, B, A...)
 */
function drawVectorscope(canvas, pixelData) {
    const ctx = canvas.getContext('2d');
    const size = 250; 
    
    // Canvasã®ç‰©ç†ã‚µã‚¤ã‚ºã‚’è¨­å®š (CSSã‚µã‚¤ã‚ºã¨ä¸€è‡´ã•ã›ã‚‹ã“ã¨ã§ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ãªã—ã§æç”»)
    canvas.width = size;
    canvas.height = size;

    const center = size / 2;
    const radius = size / 2 - 15; // å††ã®åŠå¾„ (ãƒãƒ¼ã‚¸ãƒ³ã®ãŸã‚å°‘ã—å°ã•ã)
    const numPixels = pixelData.length / 4;
    const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--scope-grid-color').trim();

    // 1. èƒŒæ™¯ã¨ä¸­å¿ƒç·šã®æç”»
    ctx.fillStyle = 'var(--scope-bg-color)'; 
    ctx.fillRect(0, 0, size, size);
    
    // ä¸­å¿ƒç·š (åå­—ç·š)
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(center, 0); ctx.lineTo(center, size); // å‚ç›´
    ctx.moveTo(0, center); ctx.lineTo(size, center); // æ°´å¹³
    ctx.stroke();

    // 2. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå††ã¨ç›®ç››ã‚Šã®æç”»
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 1;
    
    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå†† (æ¨™æº–çš„ãª66%ã¨100%ã®ç›®ç››ã‚Š)
    ctx.beginPath();
    ctx.arc(center, center, radius * 0.66, 0, 2 * Math.PI); 
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(center, center, radius, 0, 2 * Math.PI); // å¤–æ 
    ctx.stroke();

    // å¤–å´ã®30åº¦ã”ã¨ã®æ™‚é–“è»¸ç›®ç››ã‚Š (1æšç›®ã®ç”»åƒã‚’å‚è€ƒã«)
    for (let i = 0; i < 360; i += 30) {
        const rad = i * (Math.PI / 180);
        const startR = radius * 1.05;
        const endR = radius * 1.15;
        
        const x1 = center + startR * Math.sin(rad);
        const y1 = center - startR * Math.cos(rad);
        const x2 = center + endR * Math.sin(rad);
        const y2 = center - endR * Math.cos(rad);

        ctx.lineWidth = i % 90 === 0 ? 1.5 : 1; // 90åº¦ã”ã¨ã‚’å¤ªã
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }


    // 3. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç‚¹ (R, M, B, C, G, Y) ã®æç”»
    // è§’åº¦ (åº¦) - 0åº¦=ä¸Š (Y), 30=M, 90=B, 150=C, 210=G, 270=R (ãƒ—ãƒ­ã®ãƒ“ãƒ‡ã‚ªã‚¹ã‚³ãƒ¼ãƒ—æ…£ä¾‹)
    const primaryColors = [
        { label: 'Y', angle: 0, color: '#FFFF00' },
        { label: 'M', angle: 30, color: '#FF00FF' },  
        { label: 'B', angle: 90, color: '#0000FF' },  
        { label: 'C', angle: 150, color: '#00FFFF' }, 
        { label: 'G', angle: 210, color: '#00FF00' }, 
        { label: 'R', angle: 330, color: '#FF0000' }  
    ];

    primaryColors.forEach(pc => {
        // è§’åº¦ã‚’ãƒ©ã‚¸ã‚¢ãƒ³ã«å¤‰æ›ã—ã€Canvasã®åº§æ¨™ç³»ã«åˆã‚ã›ã‚‹ (0åº¦ãŒä¸Š)
        const rad = pc.angle * (Math.PI / 180);
        
        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½® (å†…å´ã®ãƒãƒ¼ã‚«ãƒ¼) - 80%ã®ä½ç½®ã«å°ã•ãªã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’é…ç½®
        const markerRadius = radius * 0.8; 
        const x_marker = center + markerRadius * Math.sin(rad);
        const y_marker = center - markerRadius * Math.cos(rad);

        // ãƒ©ãƒ™ãƒ«ä½ç½® (å¤–å´ã®ãƒ©ãƒ™ãƒ«)
        const labelRadius = radius * 1.3; // ç›®ç››ã‚Šã®å¤–å´
        const x_label = center + labelRadius * Math.sin(rad);
        const y_label = center - labelRadius * Math.cos(rad);

        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹ã®æç”»
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 1;
        const boxSize = 15;
        ctx.beginPath();
        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ç¤ºã™å››è§’å½¢ã®ç·š (1æšç›®ã®ç”»åƒã‚’å‚è€ƒã«)
        ctx.moveTo(x_marker - boxSize/2, y_marker - boxSize/2 + 5);
        ctx.lineTo(x_marker - boxSize/2, y_marker - boxSize/2);
        ctx.lineTo(x_marker - boxSize/2 + 5, y_marker - boxSize/2);
        
        ctx.moveTo(x_marker + boxSize/2 - 5, y_marker - boxSize/2);
        ctx.lineTo(x_marker + boxSize/2, y_marker - boxSize/2);
        ctx.lineTo(x_marker + boxSize/2, y_marker - boxSize/2 + 5);

        ctx.moveTo(x_marker + boxSize/2, y_marker + boxSize/2 - 5);
        ctx.lineTo(x_marker + boxSize/2, y_marker + boxSize/2);
        ctx.lineTo(x_marker + boxSize/2 - 5, y_marker + boxSize/2);

        ctx.moveTo(x_marker - boxSize/2 + 5, y_marker + boxSize/2);
        ctx.lineTo(x_marker - boxSize/2, y_marker + boxSize/2);
        ctx.lineTo(x_marker - boxSize/2, y_marker + boxSize/2 - 5);
        ctx.stroke();
        
        // ãƒ©ãƒ™ãƒ«ã®æç”»
        ctx.fillStyle = gridColor;
        ctx.font = '12px var(--font-futura)';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(pc.label, x_label, y_label);
    });


    // 4. ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã®ãƒ—ãƒ­ãƒƒãƒˆ (YCrCb)
    const maxChrominance = 0.5; // YCrCbã®ç†è«–ä¸Šã®æœ€å¤§åå·®
    const plotRadius = radius; 

    // æç”»ã‚¹ã‚¿ã‚¤ãƒ«: ç‚¹ã‚’é‡ã­ã¦æ˜ã‚‹ãã—ã€è‰²åˆ†å¸ƒã‚’è¦–è¦šåŒ–
    ctx.globalCompositeOperation = 'lighter'; // ç‚¹ã‚’é‡ã­ã¦æ˜ã‚‹ãã™ã‚‹ (è¦‹ã‚„ã™ãã™ã‚‹ãŸã‚)
    
    // ã‚¹ã‚­ãƒƒãƒ—ãƒ¬ãƒ¼ãƒˆã‚’è¨­å®š (ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ãŸã‚ã€å…¨ã¦ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚’ãƒ—ãƒ­ãƒƒãƒˆã—ãªã„)
    const skip = Math.max(1, Math.floor(numPixels / 100000)); 
    
    for (let i = 0; i < pixelData.length; i += 4 * skip) {
        const r = pixelData[i] / 255;
        const g = pixelData[i+1] / 255;
        const b = pixelData[i+2] / 255;
        
        // è¼åº¦ (Y) - ITU-R BT.601
        const yNorm = 0.299 * r + 0.587 * g + 0.114 * b;
        
        // è‰²åº¦ (Cr/Cb)
        const cbNorm = b - yNorm; // Cb (Blue-Y) -> Xè»¸
        const crNorm = r - yNorm; // Cr (Red-Y) -> Yè»¸

        // è‰²åº¦ã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã«ãƒãƒƒãƒ”ãƒ³ã‚°: [-0.5, 0.5] ã‚’ [-plotRadius, plotRadius] ã«å¤‰æ›
        const plotCb = cbNorm * (plotRadius / maxChrominance);
        const plotCr = crNorm * (plotRadius / maxChrominance);

        // Canvasåº§æ¨™: X = Center + Cb, Y = Center - Cr 
        // Cr (R-Y)ã¯ãƒ“ãƒ‡ã‚ªã‚¹ã‚³ãƒ¼ãƒ—ã®æ…£ä¾‹ã§ä¸‹å‘ããŒæ­£ã®ãŸã‚ã€Yè»¸ã‚’åè»¢ã•ã›ã‚‹
        const plotX = center + plotCb; 
        const plotY = center + plotCr; // æ…£ä¾‹çš„ã«B-Y(Cb)ãŒæ°´å¹³ã€R-Y(Cr)ãŒå‚ç›´ä¸‹å‘ãã‚’æ­£ã¨ã—ã¦ãƒ—ãƒ­ãƒƒãƒˆ

        // å††å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        const dx = plotX - center;
        const dy = plotY - center;
        if (dx * dx + dy * dy <= plotRadius * plotRadius) {
            
            // è¼åº¦ã¨å½©åº¦ã«åŸºã¥ã„ãŸè‰²ã‚’è¨­å®š (ãƒ—ãƒ­ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¯ç‚¹ã®è‰²ã‚‚è¡¨ç¤ºã™ã‚‹ãŸã‚)
            const hue = Math.atan2(plotCr, plotCb) * (180 / Math.PI) + 180; // 0-360
            const sat = Math.sqrt(dx*dx + dy*dy) / plotRadius; // 0-1
            
            // HSL/HSVã‹ã‚‰RGBã¸ã®å¤‰æ›é–¢æ•°ãŒå¿…è¦ã ãŒã€ã“ã“ã§ã¯å˜ç´”ãªè‰²ç›¸ç’°ã§ä»£ç”¨
            ctx.fillStyle = `hsl(${hue}, 100%, ${50 + sat * 40}%)`; 
            
            // æç”» (ç‚¹ã§è¡¨ç¤º)
            ctx.fillRect(plotX, plotY, 1.5, 1.5); 
        }
    }
    
    ctx.globalCompositeOperation = 'source-over'; // å…ƒã«æˆ»ã™

    // 5. ä¸­å¿ƒç‚¹ã®æç”» (ç™½)
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(center - 1, center - 1, 3, 3);
}


function rgbToHex(r,g,b) {
return "#" + [r,g,b].map(x => x.toString(16).padStart(2, '0')).join('').toUpperCase();
}

function getLuminance(hex) {
const r = parseInt(hex.slice(1, 3), 16) / 255;
const g = parseInt(hex.slice(3, 5), 16) / 255;
const b = parseInt(hex.slice(5, 7), 16) / 255;

const toLinear = (c) => (c <= 0.03928) ? c / 12.92 : ((c + 0.055) / 1.055) ** 2.4;

const L = 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
return L;
}

function getContrastRatio(hex1, hex2) {
const L1 = getLuminance(hex1);
const L2 = getLuminance(hex2);
return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
}

// --- 5. ã‚³ãƒ”ãƒ¼/ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ ---

function copyTextToClipboard(e) {
const item = e.currentTarget;
const targetId = item.dataset.copyTarget;
let textToCopy = '';

switch(targetId) {
case 'blackRatio':
textToCopy = DOM.values.blackRatio.textContent.replace('%', '');
break;
case 'whiteRatio':
textToCopy = DOM.values.whiteRatio.textContent.replace('%', '');
break;
case 'lightColor':
textToCopy = DOM.values.lightColor.textContent;
break;
case 'darkColor':
textToCopy = DOM.values.darkColor.textContent;
break;
case 'contrastRatio':
textToCopy = DOM.values.contrastRatio.textContent.replace(':1', '');
break;
}

if (textToCopy) {
// navigator.clipboard.writeText()ã‚’ä½¿ç”¨ (iframeå†…ã§ã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŒã€Canvasç’°å¢ƒã§ã¯è¨±å¯ã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹)
navigator.clipboard.writeText(textToCopy).then(() => {
showTooltip(e.clientX, e.clientY);
}).catch(err => {
console.error('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ:', err);
// ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒå¿…è¦ãªå ´åˆã¯ã“ã“ã«è¨˜è¿°
});
}
}

let tooltipTimeout;
function showTooltip(x, y) {
DOM.copyTooltip.style.left = `${x + 10}px`;
DOM.copyTooltip.style.top = `${y - 20}px`;
DOM.copyTooltip.classList.add('show');

clearTimeout(tooltipTimeout);
tooltipTimeout = setTimeout(() => {
DOM.copyTooltip.classList.remove('show');
}, 1500);
}

function downloadCanvasImage(canvas, filename) {
const link = document.createElement('a');
link.download = filename || 'image.png';
canvas.toBlob((blob) => {
link.href = URL.createObjectURL(blob);
link.click();
URL.revokeObjectURL(link.href);
}, 'image/png');
}
</script>
</body>
</html>